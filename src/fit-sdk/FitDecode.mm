////////////////////////////////////////////////////////////////////////////////
// The following FIT Protocol software provided may be used with FIT protocol
// devices only and remains the copyrighted property of Garmin Canada Inc.
// The software is being provided on an "as-is" basis and as an accommodation,
// and therefore all warranties, representations, or guarantees of any kind
// (whether express, implied or statutory) including, without limitation,
// warranties of merchantability, non-infringement, or fitness for a particular
// purpose, are specifically disclaimed.
//
// Copyright 2020 Garmin Canada Inc.
////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.40Release
// Tag = production/akw/21.40.00-0-g813c158
////////////////////////////////////////////////////////////////////////////////


#import <Foundation/Foundation.h>
#import "FitDecode.h"

#include "fit_accumulator.hpp"
#include "fit_accumulated_field.hpp"
#include "fit_crc.hpp"
#include "fit_field.hpp"
#include "fit_mesg.hpp"
#include "fit_mesg_definition.hpp"
#include "fit_developer_data_id_mesg.hpp"
#include "fit_field_description_mesg.hpp"
#include "fit_developer_field_definition.hpp"

const FIT_UINT8 DevFieldNumOffset = 0;
const FIT_UINT8 DevFieldSizeOffset = 1;
const FIT_UINT8 DevFieldIndexOffset = 2;
const FIT_UINT16 BufferSize = 512;

// Declare all private variables and functions
@interface FitDecode ()

- (void) UpdateEndianness:(FIT_UINT8) type withSize:(FIT_UINT8) size;
- (void) AddDeveloperDataMessageToLookup:(fit::Mesg) mesg;
- (void) ClearDeveloperDataLookup;

    @property FIT_UINT8 *buffer;
    @property FIT_BOOL hasDevData;
    @property STATE state;
    @property FIT_UINT8 fileHdrOffset;
    @property FIT_UINT8 fileHdrSize;
    @property FIT_UINT32 fileDataSize;
    @property FIT_UINT32 fileBytesLeft;
    @property FIT_UINT16 crc;
    @property fit::Mesg mesg;
    @property FIT_UINT8 localMesgIndex;
    @property fit::MesgDefinition *localMesgDefs;
    @property FIT_UINT8 *archs;
    @property FIT_UINT8 *fieldData;
    @property FIT_UINT8 numFields;
    @property FIT_UINT8 fieldIndex;
    @property FIT_UINT8 fieldDataIndex;
    @property FIT_UINT8 fieldBytesLeft;
    @property FIT_UINT8 lastTimeOffset;
    @property FIT_UINT32 timestamp;
    @property fit::Accumulator accumulator;
    @property fit::MesgListener* mesgListener;
    @property fit::MesgDefinitionListener* mesgDefinitionListener;
    @property FIT_BOOL _pause;
    @property NSString *headerException;
    @property FIT_BOOL skipHeader;
    @property FIT_BOOL streamIsComplete;
    @property FIT_BOOL invalidDataSize;
    @property FIT_UINT32 currentByteOffset;
    @property FIT_UINT32 currentByteIndex;
    @property FIT_UINT32 bytesRead;
    @property FILE *decode_file;
    @property NSMutableDictionary *developerDataIds;
    @property NSMutableDictionary *developerDataDescriptions;
@end

@implementation FitDecode

// Synthesize private variables

@synthesize buffer;
@synthesize hasDevData;
@synthesize state;
@synthesize fileHdrOffset;
@synthesize fileHdrSize;
@synthesize fileDataSize;
@synthesize fileBytesLeft;
@synthesize crc;
@synthesize mesg;
@synthesize localMesgIndex;
@synthesize localMesgDefs;
@synthesize archs;
@synthesize fieldData;
@synthesize numFields;
@synthesize fieldIndex;
@synthesize fieldDataIndex;
@synthesize fieldBytesLeft;
@synthesize lastTimeOffset;
@synthesize timestamp;
@synthesize accumulator;
@synthesize mesgListener;
@synthesize mesgDefinitionListener;
@synthesize _pause;
@synthesize headerException;
@synthesize skipHeader;
@synthesize streamIsComplete;
@synthesize invalidDataSize;
@synthesize currentByteOffset;
@synthesize currentByteIndex;
@synthesize bytesRead;
@synthesize decode_file;
@synthesize developerDataIds;
@synthesize developerDataDescriptions;

- (id)init
{
    self = [super init];
    if (self)
    {
        localMesgDefs = new fit::MesgDefinition[FIT_MAX_LOCAL_MESGS];
        archs = new FIT_UINT8[FIT_MAX_LOCAL_MESGS];
        fieldData = new FIT_UINT8[FIT_MAX_FIELD_SIZE];
        buffer = new FIT_UINT8[BufferSize];

        developerDataIds = [[NSMutableDictionary alloc] init];
        developerDataDescriptions = [[NSMutableDictionary alloc] init];

        for (int i=0; i<FIT_MAX_LOCAL_MESGS; i++)
        {
            localMesgDefs[i] = fit::MesgDefinition();
            localMesgDefs[i].SetLocalNum((FIT_UINT8) i);
        }

        headerException = @"";
        streamIsComplete = FIT_TRUE;
        skipHeader = FIT_FALSE;
        invalidDataSize = FIT_FALSE;
        decode_file = NULL;
        currentByteOffset = 0;
        streamIsComplete = FIT_FALSE;
        bytesRead = 0;
        currentByteIndex = 0;
        mesgListener = NULL;
        mesgDefinitionListener = NULL;
    }
    return self;
}

-(void)finalize
{
    //Clean-up managed resources if not already done
    if(localMesgDefs!= NULL) { delete[] localMesgDefs; localMesgDefs = NULL;}
    if(archs!= NULL) { delete[] archs; archs = NULL;}
    if(fieldData!= NULL) { delete[] fieldData; fieldData = NULL;}
    if(buffer!= NULL) { delete[] buffer; buffer = NULL;}
    [self ClearDeveloperDataLookup];
    developerDataIds = NULL;
    developerDataDescriptions = NULL;
    [super finalize];
}

-(void)dealloc
{
    //Clean-up managed resources if not already done
    if(localMesgDefs!= NULL) { delete[] localMesgDefs; localMesgDefs = NULL;}
    if(archs!= NULL) { delete[] archs; archs = NULL;}
    if(fieldData!= NULL) { delete[] fieldData; fieldData = NULL;}
    if(buffer!= NULL) { delete[] buffer; buffer = NULL;}
    [self ClearDeveloperDataLookup];
    developerDataIds = NULL;
    developerDataDescriptions = NULL;
}

- (FIT_BOOL)IsFit:(FILE *)file
{
    FIT_BOOL returnValue = FIT_FALSE;

    [self InitRead:file];

    do
    {
        if ( currentByteIndex == 0 )
        {
            bytesRead = (FIT_UINT32)fread(buffer, 1, BufferSize, file);
        }
        for ( ; currentByteIndex < bytesRead; currentByteIndex++ )
        {
            if ([self ReadByte:buffer[currentByteIndex]] != RETURN_CONTINUE)
            {
                returnValue = FIT_FALSE; // Error processing file header (not FIT).
                break;
            }
            if (state != STATE_FILE_HDR)
            {
                returnValue = FIT_TRUE; // File header processed successfully.
                break;
            }
        }
        currentByteIndex = 0;
    } while ( !ferror(file) && !feof(file) && ( state == STATE_FILE_HDR ) );

    [self InitRead:file];

    return returnValue;
}

- (FIT_BOOL) CheckIntegrity:(FILE *) file
{
    FIT_BOOL status = FIT_TRUE;

    [self InitRead:file];

    do
    {
        if ( currentByteIndex == 0 )
        {
            bytesRead = (FIT_UINT32)fread(buffer, 1, BufferSize, file);
        }

        for ( ; currentByteIndex < bytesRead; currentByteIndex++ )
        {
            switch ([self ReadByte:buffer[currentByteIndex]])
            {
                case RETURN_CONTINUE:
                case RETURN_MESG_DEF:
                    break;

                case RETURN_MESG:
                    [self AddDeveloperDataMessageToLookup:mesg];
                    break;

                case RETURN_END_OF_FILE:
                    status = FIT_TRUE;
                    [self InitRead:file startOfFile:FIT_FALSE];
                    break;

                default:
                    status = FIT_FALSE;
                    break;
            }
        }
        currentByteIndex = 0;
    } while ( !ferror(file) && !feof(file) && (status == FIT_TRUE) );

    [self InitRead:file];

    return status;
}

- (void) SkipHeader
{
    // Do not allow changing the settings after Read has started.
    if (decode_file != NULL)
    {
        [NSException raise:@"Fit decode error" format:@"Can't set skipHeader option after Decode started!"];
    }
    // Skip header decode
    state = STATE_RECORD;
    // Decode until we hit EOF, don't consider CRC.
    skipHeader = FIT_TRUE;
}

- (void) IncompleteStream
{
    // Do not allow changing the settings after Read has started.
    if (decode_file != NULL)
    {
        [NSException raise:@"Fit decode error" format:@"Can't set incompleteStream option after Decode started!"];
    }
    // Don't raise an error if eof is encountered during decode,
    // caller may try to resume if more bytes arrive.
    streamIsComplete = FIT_FALSE;
}

- (FIT_BOOL) Read:(FILE *) file
{
    FIT_BOOL status = FIT_TRUE;
    long fileSize;

    decode_file = file;
    currentByteOffset = 0;
    [self InitRead:file];

    //Read out the size of the file
    fseek(decode_file, 0L, SEEK_END);
    fileSize = ftell(decode_file);
    fseek(decode_file, 0L, SEEK_SET);

    while ( ( currentByteOffset < fileSize ) && (status == FIT_TRUE) )
    {
        [self InitRead:file startOfFile:FIT_FALSE];
        status = [self Resume];
    }

    return status;
}

- (FIT_BOOL) Read:(FILE *)file withMesgListener:(fit::MesgListener *) listener
{
    mesgListener = listener;
    mesgDefinitionListener = NULL;
    return [self Read:file];
}

- (FIT_BOOL) Read:(FILE *)file withListener:(fit::MesgListener *) listener andDefListener:(fit::MesgDefinitionListener *) defListener
{
    mesgListener = listener;
    mesgDefinitionListener = defListener;
    return [self Read:file];
}

- (void) Pause
{
    _pause = FIT_TRUE;
}

- (FIT_BOOL) Resume
{
    _pause = FIT_FALSE;
    RETURN decodeReturn = RETURN_CONTINUE;

    do
    {
        if ( currentByteIndex == 0 )
        {
            bytesRead = (FIT_UINT32)fread(buffer, 1, BufferSize, decode_file);
        }

        for (; currentByteIndex < bytesRead; currentByteIndex++)
        {
            if (_pause)
                return FIT_FALSE;

            decodeReturn = [self ReadByte:(FIT_UINT8)buffer[currentByteIndex]];

            switch (decodeReturn)
            {
                case RETURN_CONTINUE:
                    break;

                case RETURN_MESG:
                    [self AddDeveloperDataMessageToLookup:mesg];

                    if (mesgListener)
                        mesgListener->OnMesg(mesg);
                    break;

                case RETURN_MESG_DEF:
                    if (mesgDefinitionListener)
                        mesgDefinitionListener->OnMesgDefinition(localMesgDefs[localMesgIndex]);
                    break;

                case RETURN_END_OF_FILE:
                    currentByteIndex++;
                    currentByteOffset++;
                    return FIT_TRUE;

                default:
                    currentByteOffset++;
                    return FIT_TRUE;
            }
            currentByteOffset++;
       }
       currentByteIndex = 0;
    } while ( !ferror(decode_file) && !feof(decode_file) );

    if ((streamIsComplete == FIT_TRUE) && (skipHeader == FIT_FALSE))
    {
        // When decoding a complete file we should exit via RETURN_END_OF_FILE state only.//
        [NSException raise:@"FIT decode error" format:@"Unexpected end of input stream at byte:  %d", currentByteOffset];
    }
    if (streamIsComplete == FIT_FALSE)
    {
        // If stream is not yet complete caller can resume() when there is more data
        // or decide there was an error.
        if ((decodeReturn == RETURN_MESG) || (decodeReturn == RETURN_MESG_DEF))
        {
            // Our stream ended on a complete message, maybe we are done decoding.
            return FIT_TRUE;
        }
        else
        {
            // EOF was encountered mid message. Caller may want to resume once
            // more bytes are available.
            return FIT_FALSE;
        }
    }
    // if Decoding Records section only, file should end on a complete message
    // (unless incomplete stream option above was also used)
    else
    {
        if ((decodeReturn == RETURN_MESG) || (decodeReturn == RETURN_MESG_DEF))
        {
            // Our stream ended on a complete message, we are done decoding.
            return FIT_TRUE;
        }
        else
        {
            if (invalidDataSize == FIT_FALSE)
            {
                [NSException raise:@"FIT decode error" format:@"Unexpected end of input stream at byte:  %d", currentByteOffset];
            }
            else
            {
                return FIT_TRUE;
            }
        }
    }
    return FIT_FALSE;
}

- (void) AddDeveloperDataMessageToLookup: (fit::Mesg) mesg
{
    if (mesg.GetNum() == FIT_MESG_NUM_DEVELOPER_DATA_ID)
    {
        fit::DeveloperDataIdMesg *developerDataIdMesg = new fit::DeveloperDataIdMesg(mesg);
        FIT_UINT8 developerDataIndex = developerDataIdMesg->GetDeveloperDataIndex();
        NSValue *val = [NSValue valueWithPointer:developerDataIdMesg];
        NSString *key = [NSString stringWithFormat:@"%d", developerDataIndex];
        [developerDataIds setValue:val forKey:key];
        [developerDataDescriptions setValue:[[NSMutableDictionary alloc] init] forKey:key];
    }
    else if (mesg.GetNum() == FIT_MESG_NUM_FIELD_DESCRIPTION)
    {
        fit::FieldDescriptionMesg *fieldDescriptionMesg = new fit::FieldDescriptionMesg(mesg);
        FIT_UINT8 developerDataIndex = fieldDescriptionMesg->GetDeveloperDataIndex();
        FIT_UINT8 fieldDefinitionNumber = fieldDescriptionMesg->GetFieldDefinitionNumber();

        try
        {
            NSValue *val = [NSValue valueWithPointer:fieldDescriptionMesg];
            NSString *key = [NSString stringWithFormat:@"%d", developerDataIndex];
            NSString *fieldNumber = [NSString stringWithFormat:@"%d", fieldDefinitionNumber];
            NSMutableDictionary *descriptionsForDevloperId = (NSMutableDictionary *)[developerDataDescriptions valueForKey:key];
            [descriptionsForDevloperId setValue:val forKey:fieldNumber];

        }
        catch (std::out_of_range)
        {
            // Description without a Developer Data Id Message
        }
    }
}

- (void) ClearDeveloperDataLookup
{
    for (NSString *developerDataIndex in [developerDataIds allKeys])
    {
        NSValue *val = [developerDataIds valueForKey:developerDataIndex];
        const fit::DeveloperDataIdMesg* developerDataIdMesg = (fit::DeveloperDataIdMesg *)[val pointerValue];
        delete developerDataIdMesg;
        [developerDataIds removeObjectForKey:developerDataIndex];
    }

    for (NSString *developerDataIndex in [developerDataDescriptions allKeys])
    {
        NSMutableDictionary *descriptionsForDeveloperId = (NSMutableDictionary *)[developerDataDescriptions valueForKey:developerDataIndex];

        for (NSString *key in [descriptionsForDeveloperId allKeys])
        {
            NSValue *val = [descriptionsForDeveloperId valueForKey:key];
            const fit::FieldDescriptionMesg* fieldDescriptionMesg = (fit::FieldDescriptionMesg *)[val pointerValue];
            delete fieldDescriptionMesg;
            [descriptionsForDeveloperId removeObjectForKey:key];
        }

        [developerDataDescriptions removeObjectForKey:developerDataIndex];
    }
}

- (FIT_BOOL) GetInvalidDataSize
{
    return invalidDataSize;
}

- (void) SetInvalidDataSize:(FIT_BOOL) value
{
    invalidDataSize = value;
}

- (void)InitRead:(FILE *) file
{
    [self InitRead:file startOfFile:FIT_TRUE];
}

- (void)InitRead:(FILE *) file startOfFile:(FIT_BOOL) start
{
    fileBytesLeft = 3; // Header byte + CRC.
    fileHdrOffset = 0;
    crc = 0;
    headerException = @"";
    memset(fieldData, 0, sizeof(FIT_UINT8)*FIT_MAX_FIELD_SIZE);
    // Only reset to header state if we do not want
    // to skip the header.
    if (skipHeader == FIT_FALSE)
        state = STATE_FILE_HDR;
    lastTimeOffset = 0;
    // Reset to the beginning of the file
    if ( start == FIT_TRUE)
    {
        fseek(file, 0, SEEK_SET);
        [self ClearDeveloperDataLookup];
    }
    clearerr(file);
}

- (void) UpdateEndianness:(FIT_UINT8) type withSize:(FIT_UINT8) size
{
    FIT_UINT8 typeSize = fit::baseTypeSizes[type & FIT_BASE_TYPE_NUM_MASK];

    if (((type & FIT_BASE_TYPE_ENDIAN_FLAG) != 0) &&
        ((archs[localMesgIndex] & FIT_ARCH_ENDIAN_MASK) != FIT_ARCH_ENDIAN_LITTLE))
    {
        // Swap the bytes for each element.
        for (int element = 0; element < size; element++)
        {
            for (int i = 0; i < (typeSize / 2); i++)
            {
                FIT_UINT8 tmp = fieldData[element * typeSize + i];
                fieldData[element * typeSize + i] = fieldData[element * typeSize + typeSize - i - 1];
                fieldData[element * typeSize + typeSize - i - 1] = tmp;
            }
        }
    }
}

- (RETURN) ReadByte:(FIT_UINT8) data
{
    NSValue *val;
    NSString *key;
    NSString *fldDesc;

    if ((fileBytesLeft > 0) && (skipHeader == FIT_FALSE))
    {
        crc = fit::CRC::Get16(crc, data);

        fileBytesLeft--;

        if (fileBytesLeft == 1) // CRC low byte.
        {
            if (state != STATE_RECORD)
            {
                [NSException raise:@"FIT decode error" format:@"Decoder not in correct state after last data byte in file Check message definitions. Error at byte: %d", currentByteOffset];
                return RETURN_ERROR;
            }

            return RETURN_CONTINUE; // Next byte.
        }
        else if (fileBytesLeft == 0) // CRC high byte.
        {
            if (crc != 0)
            {
                [NSException raise:@"FIT decode error" format:@"File CRC failed. Error at byte: %d", currentByteOffset];
                return RETURN_ERROR;
            }

            return RETURN_END_OF_FILE;
        }
    }

    switch (state) {
        case STATE_FILE_HDR:
            switch (fileHdrOffset++)
        {
            case 0:
                fileHdrSize = data;
                fileBytesLeft = fileHdrSize + 2;
                break;
            case 1:
                if ((data & FIT_PROTOCOL_VERSION_MAJOR_MASK) > (FIT_PROTOCOL_VERSION_MAJOR << FIT_PROTOCOL_VERSION_MAJOR_SHIFT))
                {
                    NSString *message = [NSString stringWithFormat:@"Protocol version %d.%d not supported. Must be %d or earlier.", (data & FIT_PROTOCOL_VERSION_MAJOR_MASK) << FIT_PROTOCOL_VERSION_MAJOR_SHIFT, (data & FIT_PROTOCOL_VERSION_MINOR_MASK), FIT_PROTOCOL_VERSION_MAJOR];
                    headerException = message;
                }
                break;
            case 4:
                fileDataSize = data & 0xFF;
                break;
            case 5:
                fileDataSize |= (FIT_UINT32) (data & 0xFF) << 8;
                break;
            case 6:
                fileDataSize |= (FIT_UINT32) (data & 0xFF) << 16;
                break;
            case 7:
                fileDataSize |= (FIT_UINT32) (data & 0xFF) << 24;
                if ( (fileDataSize == 0) && (invalidDataSize == FIT_FALSE) )
                {
                    invalidDataSize = FIT_TRUE;
                    NSString *message = [NSString stringWithFormat:@"File Size is 0. Error at byte : %d", currentByteOffset];
                    headerException = message;
                }
                break;
            case 8:
                if (data != '.')
                {
                    NSString *message = [NSString stringWithFormat:@"File header signature mismatch.  File is not FIT. Error at byte : %d", currentByteOffset];
                    headerException = message;
                }
                break;
            case 9:
                if (data != 'F')
                {
                    NSString *message = [NSString stringWithFormat:@"File header signature mismatch.  File is not FIT. Error at byte : %d", currentByteOffset];
                    headerException = message;
                }
                break;
            case 10:
                if (data != 'I')
                {
                    NSString *message = [NSString stringWithFormat:@"File header signature mismatch.  File is not FIT. Error at byte : %d", currentByteOffset];
                    headerException = message;
                }
                break;
            case 11:
                if (data != 'T')
                {
                    NSString *message = [NSString stringWithFormat:@"File header signature mismatch.  File is not FIT. Error at byte : %d", currentByteOffset];
                    headerException = message;
                }

                //If headerException length > 0, throw exception
                if ([headerException length])
                {
                    [NSException raise:@"Fit decode error" format:@"%@", headerException];
                }
                break;
            default:
                break;
        }

            if (fileHdrOffset == fileHdrSize)
            {
                fileBytesLeft = fileDataSize + 2; // include crc
                state = STATE_RECORD;

                // We don't care about the CRC when the file size is invalid
                if (invalidDataSize)
                {
                    skipHeader = FIT_TRUE;
                }
            }
            break;

        case STATE_RECORD:
            fieldIndex = 0;
            fieldBytesLeft = 0;

            if (fileBytesLeft > 1) {
                if ((data & FIT_HDR_TIME_REC_BIT) != 0) {
                    fit::Field timestampField = fit::Field(fit::Profile::MESG_RECORD, fit::Profile::RECORD_MESG_TIMESTAMP);
                    FIT_UINT8 timeOffset = data & FIT_HDR_TIME_OFFSET_MASK;

                    timestamp += (timeOffset - lastTimeOffset) & FIT_HDR_TIME_OFFSET_MASK;
                    lastTimeOffset = timeOffset;
                    timestampField.SetUINT32Value(timestamp);

                    localMesgIndex = (data & FIT_HDR_TIME_TYPE_MASK) >> FIT_HDR_TIME_TYPE_SHIFT;

                    if (localMesgDefs[localMesgIndex].GetNum() == FIT_MESG_NUM_INVALID)
                    {
                        NSString *message = [NSString stringWithFormat:@"Missing FIT message definition for local message number %d. Error at byte: %d",localMesgIndex, currentByteOffset];
                        [NSException raise:@"Fit decode error" format:@"%@", message];
                        return RETURN_ERROR;
                    }

                    mesg = fit::Mesg(localMesgDefs[localMesgIndex].GetNum());
                    mesg.SetLocalNum(localMesgIndex);
                    mesg.AddField(timestampField);

                    if (localMesgDefs[localMesgIndex].GetFields().size() == 0)
                        return RETURN_MESG;

                    state = STATE_FIELD_DATA;
                }
                else
                {
                    localMesgIndex = data & FIT_HDR_TYPE_MASK;

                    if ((data & FIT_HDR_TYPE_DEF_BIT) != 0)
                    {
                        hasDevData = ((data & FIT_HDR_DEV_FIELD_BIT) != 0);
                        state = STATE_RESERVED1;
                    }
                    else
                    {
                        if (localMesgDefs[localMesgIndex].GetNum() == FIT_MESG_NUM_INVALID)
                        {
                            NSString *message = [NSString stringWithFormat:@"Missing FIT message definition for local message number %d. Error at byte: %d",localMesgIndex, currentByteOffset];
                            [NSException raise:@"Fit decode error" format:@"%@", message];
                            return RETURN_ERROR;
                        }

                        mesg = fit::Mesg(localMesgDefs[localMesgIndex].GetNum());
                        mesg.SetLocalNum(localMesgIndex);

                        if (localMesgDefs[localMesgIndex].GetFields().size() != 0)
                        {
                            state = STATE_FIELD_DATA;
                        }
                        else if (localMesgDefs[localMesgIndex].GetDevFields().size() != 0)
                        {
                            state = STATE_DEV_FIELD_DATA;
                        }
                        else
                        {
                            return RETURN_MESG;
                        }
                    }
                }
            }
            else
            {
                // We just got the low byte of the crc.
                state = STATE_FILE_CRC_HIGH;
            }
            break;

        case STATE_RESERVED1:
            localMesgDefs[localMesgIndex].ClearFields();
            state = STATE_ARCH;
            break;

        case STATE_ARCH:
            archs[localMesgIndex] = data;
            state = STATE_MESG_NUM_0;
            break;

        case STATE_MESG_NUM_0:
            // Read the global message number bytes in as if they are in little endian format.
            localMesgDefs[localMesgIndex].SetNum((FIT_UINT16)data);
            state = STATE_MESG_NUM_1;
            break;

        case STATE_MESG_NUM_1:
            localMesgDefs[localMesgIndex].SetNum(localMesgDefs[localMesgIndex].GetNum() | ((FIT_UINT16)data << 8));

            // We have to check for endianness.
            if (archs[localMesgIndex] == FIT_ARCH_ENDIAN_BIG) {
                localMesgDefs[localMesgIndex].SetNum((localMesgDefs[localMesgIndex].GetNum() >> 8) | ((localMesgDefs[localMesgIndex].GetNum() & 0xFF) << 8));
            }
            else if (archs[localMesgIndex] != FIT_ARCH_ENDIAN_LITTLE)
            {
                NSString *message = [NSString stringWithFormat:@"Architecture %d not supported. Error at byte: %d", archs[localMesgIndex], currentByteOffset];
                [NSException raise:@"Fit decode error" format:@"%@", message];
                return RETURN_ERROR;
            }

            state = STATE_NUM_FIELDS;
            break;

        case STATE_NUM_FIELDS:
            numFields = data;
            fieldIndex = 0;

            if (numFields == 0)
            {
                if(hasDevData)
                {
                    state = STATE_NUM_DEV_FIELDS;
                }
                else
                {
                    state = STATE_RECORD;
                    return RETURN_MESG_DEF;
                }
            }
            else
            {
                state = STATE_FIELD_NUM;
            }
            break;

        case STATE_FIELD_NUM:
            localMesgDefs[localMesgIndex].AddField(fit::FieldDefinition());
            localMesgDefs[localMesgIndex].GetFieldByIndex(fieldIndex)->SetNum(data);
            state = STATE_FIELD_SIZE;
            break;

        case STATE_FIELD_SIZE:
            localMesgDefs[localMesgIndex].GetFieldByIndex(fieldIndex)->SetSize(data);
            state = STATE_FIELD_TYPE;
            break;

        case STATE_FIELD_TYPE:
            localMesgDefs[localMesgIndex].GetFieldByIndex(fieldIndex)->SetType(data);

            if (++fieldIndex >= numFields)
            {
                if(hasDevData)
                {
                    state = STATE_NUM_DEV_FIELDS;
                }
                else
                {
                    state = STATE_RECORD;
                    return RETURN_MESG_DEF;
                }
            }
            else
            {
                state = STATE_FIELD_NUM;
            }
            break;

        case STATE_NUM_DEV_FIELDS:
            numFields = data;
            fieldIndex = 0;

            if (numFields == 0)
            {
                state = STATE_RECORD;
                return RETURN_MESG_DEF;
            }

            state = STATE_DEV_FIELD_NUM;
            break;

        case STATE_DEV_FIELD_NUM:
            fieldData[DevFieldNumOffset] = data;
            state = STATE_DEV_FIELD_SIZE;
            break;

        case STATE_DEV_FIELD_SIZE:
            fieldData[DevFieldSizeOffset] = data;
            state = STATE_DEV_FIELD_INDEX;
            break;

        case STATE_DEV_FIELD_INDEX:
            fieldData[DevFieldIndexOffset] = data;

            try
            {
                key = [NSString stringWithFormat:@"%d", fieldData[DevFieldIndexOffset]];
                fldDesc = [NSString stringWithFormat:@"%d", fieldData[DevFieldNumOffset]];
                val = [[developerDataDescriptions valueForKey:key] valueForKey:fldDesc];
                const fit::FieldDescriptionMesg* desc = (fit::FieldDescriptionMesg *)[val pointerValue];
                val = [developerDataIds valueForKey:key];
                const fit::DeveloperDataIdMesg* developer= (fit::DeveloperDataIdMesg *)[val pointerValue];

                localMesgDefs[localMesgIndex]
                    .AddDevField(fit::DeveloperFieldDefinition(*desc, *developer, fieldData[DevFieldSizeOffset]));
            }
            catch (std::out_of_range)
            {
                // No Matching Description Message add a Generic Definition
                localMesgDefs[localMesgIndex]
                    .AddDevField(fit::DeveloperFieldDefinition(
                        fieldData[DevFieldNumOffset],
                        fieldData[DevFieldSizeOffset],
                        fieldData[DevFieldIndexOffset]));
            }

            if (++fieldIndex >= numFields)
            {
                state = STATE_RECORD;
                return RETURN_MESG_DEF;
            }

            state = STATE_DEV_FIELD_NUM;
            break;

        case STATE_FIELD_DATA:
            if (fieldBytesLeft == 0)
            {
                fieldDataIndex = 0;
                fieldBytesLeft = localMesgDefs[localMesgIndex].GetFieldByIndex(fieldIndex)->GetSize();

                if (fieldBytesLeft == 0)
                {
                    fieldBytesLeft = localMesgDefs[localMesgIndex].GetFieldByIndex(++fieldIndex)->GetSize();
                }
            }

            fieldData[fieldDataIndex++] = data;
            fieldBytesLeft--;

            if (fieldBytesLeft == 0)
            {
                fit::MesgDefinition defn = localMesgDefs[localMesgIndex];
                fit::FieldDefinition* fldDefn = defn.GetFieldByIndex(fieldIndex);
                FIT_UINT8 baseType = fldDefn->GetType() & FIT_BASE_TYPE_NUM_MASK;

                if (baseType < FIT_BASE_TYPES) // Ignore field if base type not supported.
                {
                    [self UpdateEndianness:fldDefn->GetType() withSize: fldDefn->GetSize()];

                    fit::Field field(mesg.GetNum(), fldDefn->GetNum());
                    if (field.IsValid()) // If known field type.
                    {
                        field.Read(fieldData, defn.GetFieldByIndex(fieldIndex)->GetSize());

                        // The special case time record.
                        if (defn.GetFieldByIndex(fieldIndex)->GetNum() == FIT_FIELD_NUM_TIMESTAMP)
                        {
                            timestamp = field.GetUINT32Value();
                            lastTimeOffset = (FIT_UINT8)(timestamp & FIT_HDR_TIME_OFFSET_MASK);
                        }

                        //Allows messages containing the accumulated field to set the accumulated value
                        if ( field.GetIsAccumulated() )
                        {
                            FIT_UINT8 i;
                            for (i = 0; i < field.GetNumValues(); i++)
                            {
                                FIT_FLOAT64 value = field.GetRawValue(i);
                                FIT_UINT16 j;
                                for (j = 0; j < mesg.GetNumFields(); j++)
                                {
                                    FIT_UINT16 k;
                                    fit::Field* containingField = mesg.GetFieldByIndex(j);
                                    FIT_UINT16 numComponents = containingField->GetNumComponents();

                                    for (k = 0; k < numComponents; k++)
                                    {
                                        const fit::Profile::FIELD_COMPONENT* fc = containingField->GetComponent(k);
                                        if ( ( fc->num == field.GetNum() ) && ( fc->accumulate ) )
                                        {
                                            value = ((((value / field.GetScale()) - field.GetOffset()) + fc->offset) * fc->scale);
                                        }
                                    }
                                }
                                accumulator.Set(mesg.GetNum(), field.GetNum(), (FIT_UINT32)value);
                            }
                        }

                        if (field.GetNumValues() > 0)
                        {
                            mesg.AddField(field);
                        }
                    }
                }
                fieldIndex++;
            }

            if (fieldIndex >= localMesgDefs[localMesgIndex].GetFields().size())
            {
                // Now that the entire message is decoded we may evaluate subfields and expand components
                for (FIT_UINT16 i=0; i<mesg.GetNumFields(); i++)
                {
                    FIT_UINT16 activeSubField = mesg.GetActiveSubFieldIndexByFieldIndex(i);

                    if (activeSubField == FIT_SUBFIELD_INDEX_MAIN_FIELD)
                    {
                        if (mesg.GetFieldByIndex(i)->GetNumComponents() > 0)
                        {
                            [self ExpandComponents:mesg.GetFieldByIndex(i) fromComponents: mesg.GetFieldByIndex(i)->GetComponent(0) numComponents:mesg.GetFieldByIndex(i)->GetNumComponents()];
                        }
                    }
                    else
                    {
                        if (mesg.GetFieldByIndex(i)->GetSubField(activeSubField)->numComponents > 0)
                        {
                            [self ExpandComponents:mesg.GetFieldByIndex(i) fromComponents: mesg.GetFieldByIndex(i)->GetSubField(activeSubField)->components numComponents:mesg.GetFieldByIndex(i)->GetSubField(activeSubField)->numComponents];
                        }
                    }
                }

                if (localMesgDefs[localMesgIndex].GetDevFields().size() != 0)
                {
                    fieldIndex = 0;
                    fieldBytesLeft = 0;
                    state = STATE_DEV_FIELD_DATA;
                }
                else
                {
                    state = STATE_RECORD;
                    return RETURN_MESG;
                }
            }
            break;

        case STATE_DEV_FIELD_DATA:
        {
             fit::MesgDefinition& localMesgDef = localMesgDefs[localMesgIndex];
             fit::DeveloperFieldDefinition* fieldDef = localMesgDef.GetDevFieldByIndex(fieldIndex);

             if (fieldBytesLeft == 0)
             {
                 fieldDataIndex = 0;
                 fieldBytesLeft = fieldDef->GetSize();

                 if (fieldBytesLeft == 0)
                 {
                     fieldBytesLeft = localMesgDefs->
                         GetDevFieldByIndex(++fieldIndex)->GetSize();
                 }
             }

            fieldData[fieldDataIndex++] = data;
            fieldBytesLeft--;

             if (fieldBytesLeft == 0)
             {
                 fit::MesgDefinition defn = localMesgDefs[localMesgIndex];
                 fit::DeveloperFieldDefinition* fldDefn = defn.GetDevFieldByIndex(fieldIndex);
                 FIT_UINT8 baseType = fldDefn->GetType() & FIT_BASE_TYPE_NUM_MASK;

                 if (baseType < FIT_BASE_TYPES) // Ignore field if base type not supported.
                 {
                     fit::DeveloperField field(*fldDefn);

                     [self UpdateEndianness:fldDefn->GetType() withSize:fldDefn->GetSize()];
                     field.Read(fieldData, fldDefn->GetSize());
                     mesg.AddDeveloperField(field);
                 }

                 fieldIndex++;

                 if (fieldIndex >= localMesgDef.GetDevFields().size()) {
                     // Mesg decode complete
                     state = STATE_RECORD;
                     return RETURN_MESG;
                 }
             }
            break;
        }

        default:
            break;
    }

    return RETURN_CONTINUE;
}

- (void) ExpandComponents:(fit::Field *) containingField fromComponents:(const fit::Profile::FIELD_COMPONENT*) components numComponents: (FIT_UINT16) numComponents
{
    FIT_UINT16 offset = 0;
    FIT_UINT8 i;

    for (i = 0; i < numComponents; i++)
    {
        const fit::Profile::FIELD_COMPONENT* component = &components[i];

        if (component->num != FIT_FIELD_NUM_INVALID)
        {
            fit::Field componentField(mesg.GetNum(), component->num);
            FIT_FLOAT64 value;
            FIT_UINT32 bitsValue = FIT_UINT32_INVALID;
            FIT_SINT32 signedBitsValue = FIT_SINT32_INVALID;

            if (componentField.IsSignedInteger())
            {
                signedBitsValue = containingField->GetBitsSignedValue(offset, component->bits);

                if (signedBitsValue == FIT_SINT32_INVALID)
                    break; // No more data for components.

                if (component->accumulate)
                    bitsValue = accumulator.Accumulate(mesg.GetNum(), component->num, signedBitsValue, component->bits);
            }
            else
            {
                bitsValue = containingField->GetBitsValue(offset, component->bits);

                if (bitsValue == FIT_UINT32_INVALID)
                    break; // No more data for components.

                if (component->accumulate)
                    bitsValue = accumulator.Accumulate(mesg.GetNum(), component->num, bitsValue, component->bits);
            }

            // If the component field itself has *one* component apply the scale and offset of the componentField's
            // (nested) component
            if (componentField.GetNumComponents() == 1)
            {
                if(componentField.IsSignedInteger())
                    value = ((FIT_FLOAT64)(((signedBitsValue / (FIT_FLOAT64)component->scale) - component->offset) + componentField.GetComponent(0)->offset)) * (FIT_FLOAT64)componentField.GetComponent(0)->scale;
                else
                    value = ((FIT_FLOAT64)(((bitsValue / (FIT_FLOAT64)component->scale) - component->offset) + componentField.GetComponent(0)->offset)) * (FIT_FLOAT64)componentField.GetComponent(0)->scale;
                if (mesg.HasField(componentField.GetNum()))
                {
                    fit::Field *currentField = mesg.GetField(componentField.GetNum());
                    currentField->AddRawValue(value, currentField->GetNumValues());
                }
                else
                {
                    componentField.AddRawValue(value, componentField.GetNumValues());
                    mesg.AddField(componentField);
                }
            }
            // The component field is itself a composite field (more than one component).  Don't use scale/offset, containing
            // field data must already be encoded.  Add elements to it until we have added bitsvalue
            else if (componentField.GetNumComponents() > 1)
            {
                int bitsAdded = 0;
                long mask;

                while (bitsAdded < component->bits)
                {
                    mask = ((long)1 << fit::baseTypeSizes[componentField.GetType() & FIT_BASE_TYPE_NUM_MASK]) - 1;
                    if (mesg.HasField(componentField.GetNum()))
                    {
                        mesg.GetField(componentField.GetNum())->AddValue(bitsValue & mask);
                    }
                    else
                    {
                        componentField.AddValue(bitsValue & mask, i);
                        mesg.AddField(componentField);
                    }
                    bitsValue >>= fit::baseTypeSizes[componentField.GetType() & FIT_BASE_TYPE_NUM_MASK];
                    bitsAdded += fit::baseTypeSizes[componentField.GetType() & FIT_BASE_TYPE_NUM_MASK];
                }
            }
            // componentField is an ordinary field, apply scale and offset as usual
            else
            {
                if(componentField.IsSignedInteger())
                    value = ((FIT_FLOAT64)(((signedBitsValue / (FIT_FLOAT64)component->scale) - component->offset) + componentField.GetOffset(FIT_SUBFIELD_INDEX_MAIN_FIELD))) * (FIT_FLOAT64)componentField.GetScale(FIT_SUBFIELD_INDEX_MAIN_FIELD);
                else
                    value = ((FIT_FLOAT64)(((bitsValue / (FIT_FLOAT64)component->scale) - component->offset) + componentField.GetOffset(FIT_SUBFIELD_INDEX_MAIN_FIELD))) * (FIT_FLOAT64)componentField.GetScale(FIT_SUBFIELD_INDEX_MAIN_FIELD);
                if (mesg.HasField(componentField.GetNum()))
                {
                    fit::Field *currentField = mesg.GetField(componentField.GetNum());
                    currentField->AddRawValue(value, currentField->GetNumValues());
                }
                else
                {
                    componentField.AddRawValue(value, componentField.GetNumValues());
                    mesg.AddField(componentField);
                }
            }
        }
        offset += component->bits;
    }
}

@end