// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: zwift_messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct PlayerState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var worldTime: Int64 {
    get {return _storage._worldTime}
    set {_uniqueStorage()._worldTime = newValue}
  }

  var distance: Int32 {
    get {return _storage._distance}
    set {_uniqueStorage()._distance = newValue}
  }

  var roadTime: Int32 {
    get {return _storage._roadTime}
    set {_uniqueStorage()._roadTime = newValue}
  }

  var laps: Int32 {
    get {return _storage._laps}
    set {_uniqueStorage()._laps = newValue}
  }

  var speed: Int32 {
    get {return _storage._speed}
    set {_uniqueStorage()._speed = newValue}
  }

  var roadPosition: Int32 {
    get {return _storage._roadPosition}
    set {_uniqueStorage()._roadPosition = newValue}
  }

  var cadenceUhz: Int32 {
    get {return _storage._cadenceUhz}
    set {_uniqueStorage()._cadenceUhz = newValue}
  }

  var heartrate: Int32 {
    get {return _storage._heartrate}
    set {_uniqueStorage()._heartrate = newValue}
  }

  var power: Int32 {
    get {return _storage._power}
    set {_uniqueStorage()._power = newValue}
  }

  var heading: Int64 {
    get {return _storage._heading}
    set {_uniqueStorage()._heading = newValue}
  }

  var lean: Int32 {
    get {return _storage._lean}
    set {_uniqueStorage()._lean = newValue}
  }

  var climbing: Int32 {
    get {return _storage._climbing}
    set {_uniqueStorage()._climbing = newValue}
  }

  var time: Int32 {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  var f19: Int32 {
    get {return _storage._f19}
    set {_uniqueStorage()._f19 = newValue}
  }

  var f20: Int32 {
    get {return _storage._f20}
    set {_uniqueStorage()._f20 = newValue}
  }

  var progress: Int32 {
    get {return _storage._progress}
    set {_uniqueStorage()._progress = newValue}
  }

  var customisationID: Int64 {
    get {return _storage._customisationID}
    set {_uniqueStorage()._customisationID = newValue}
  }

  var justWatching: Int32 {
    get {return _storage._justWatching}
    set {_uniqueStorage()._justWatching = newValue}
  }

  var calories: Int32 {
    get {return _storage._calories}
    set {_uniqueStorage()._calories = newValue}
  }

  var x: Float {
    get {return _storage._x}
    set {_uniqueStorage()._x = newValue}
  }

  var altitude: Float {
    get {return _storage._altitude}
    set {_uniqueStorage()._altitude = newValue}
  }

  var y: Float {
    get {return _storage._y}
    set {_uniqueStorage()._y = newValue}
  }

  var watchingRiderID: Int32 {
    get {return _storage._watchingRiderID}
    set {_uniqueStorage()._watchingRiderID = newValue}
  }

  var groupID: Int32 {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  var sport: Int64 {
    get {return _storage._sport}
    set {_uniqueStorage()._sport = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ClientToServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connected: Int32 = 0

  var riderID: Int32 = 0

  var worldTime: Int64 = 0

  var state: PlayerState {
    get {return _state ?? PlayerState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var seqno: Int32 = 0

  var tag8: Int64 = 0

  var tag9: Int64 = 0

  var lastUpdate: Int64 = 0

  var tag11: Int64 = 0

  var lastPlayerUpdate: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: PlayerState? = nil
}

struct SegmentResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 = 0

  var riderID: Int64 = 0

  var eventSubgroupID: Int64 = 0

  var firstName: String = String()

  var lastName: String = String()

  var finishTimeStr: String = String()

  var elapsedMs: Int64 = 0

  var powermeter: Int32 = 0

  var weight: Int32 = 0

  var power: Int32 = 0

  var heartrate: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SegmentResults {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var worldID: Int64 = 0

  var segmentID: Int64 = 0

  var eventSubgroupID: Int64 = 0

  var segmentResults: [SegmentResult] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// string firstName=7;
/// string lastName=8;
/// string timestamp=17;
struct UnknownMessage1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// int64 tag1=1;
/// UnknownMessage1 tag4=4;
struct UnknownMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ServerToClient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tag1: Int32 = 0

  var riderID: Int32 = 0

  var worldTime: Int64 = 0

  var seqno: Int32 = 0

  var playerStates: [PlayerState] = []

  var playerUpdates: [UnknownMessage] = []

  var tag11: Int64 = 0

  var tag17: Int64 = 0

  var numMsgs: Int32 = 0

  var msgnum: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct WorldAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var worldID: Int32 = 0

  var name: String = String()

  var tag3: Int64 = 0

  var tag5: Int64 = 0

  var worldTime: Int64 = 0

  var clockTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct WorldAttribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var worldTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct EventSubgroupProtobuf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var name: String = String()

  var rules: Int32 = 0

  var route: Int32 = 0

  var laps: Int32 = 0

  var startLocation: Int32 = 0

  var label: Int32 = 0

  var paceType: Int32 = 0

  var jerseyHash: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RiderAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var f2: Int32 = 0

  var f3: Int32 = 0

  var attributeMessage: RiderAttributes.AttributeMessage {
    get {return _attributeMessage ?? RiderAttributes.AttributeMessage()}
    set {_attributeMessage = newValue}
  }
  /// Returns true if `attributeMessage` has been explicitly set.
  var hasAttributeMessage: Bool {return self._attributeMessage != nil}
  /// Clears the value of `attributeMessage`. Subsequent reads from it will return its default value.
  mutating func clearAttributeMessage() {self._attributeMessage = nil}

  var theirID: Int32 = 0

  var f13: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct AttributeMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var myID: Int32 = 0

    var theirID: Int32 = 0

    var firstName: String = String()

    var lastName: String = String()

    var countryCode: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _attributeMessage: RiderAttributes.AttributeMessage? = nil
}

struct Profiles {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var profiles: [Profile] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Profile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var firstName: String {
    get {return _storage._firstName}
    set {_uniqueStorage()._firstName = newValue}
  }

  var lastName: String {
    get {return _storage._lastName}
    set {_uniqueStorage()._lastName = newValue}
  }

  var male: Int32 {
    get {return _storage._male}
    set {_uniqueStorage()._male = newValue}
  }

  var weight: Int32 {
    get {return _storage._weight}
    set {_uniqueStorage()._weight = newValue}
  }

  var bodyType: Int32 {
    get {return _storage._bodyType}
    set {_uniqueStorage()._bodyType = newValue}
  }

  var countryCode: Int32 {
    get {return _storage._countryCode}
    set {_uniqueStorage()._countryCode = newValue}
  }

  var totalDistance: Int32 {
    get {return _storage._totalDistance}
    set {_uniqueStorage()._totalDistance = newValue}
  }

  var totalDistanceClimbed: Int32 {
    get {return _storage._totalDistanceClimbed}
    set {_uniqueStorage()._totalDistanceClimbed = newValue}
  }

  var totalTimeInMinutes: Int32 {
    get {return _storage._totalTimeInMinutes}
    set {_uniqueStorage()._totalTimeInMinutes = newValue}
  }

  var totalWattHours: Int32 {
    get {return _storage._totalWattHours}
    set {_uniqueStorage()._totalWattHours = newValue}
  }

  var height: Int32 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  var totalExperiencePoints: Int32 {
    get {return _storage._totalExperiencePoints}
    set {_uniqueStorage()._totalExperiencePoints = newValue}
  }

  var achievementLevel: Int32 {
    get {return _storage._achievementLevel}
    set {_uniqueStorage()._achievementLevel = newValue}
  }

  var powerSource: Int32 {
    get {return _storage._powerSource}
    set {_uniqueStorage()._powerSource = newValue}
  }

  var age: Int32 {
    get {return _storage._age}
    set {_uniqueStorage()._age = newValue}
  }

  var launchedGameClient: String {
    get {return _storage._launchedGameClient}
    set {_uniqueStorage()._launchedGameClient = newValue}
  }

  var currentActivityID: Int32 {
    get {return _storage._currentActivityID}
    set {_uniqueStorage()._currentActivityID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension PlayerState: @unchecked Sendable {}
extension ClientToServer: @unchecked Sendable {}
extension SegmentResult: @unchecked Sendable {}
extension SegmentResults: @unchecked Sendable {}
extension UnknownMessage1: @unchecked Sendable {}
extension UnknownMessage: @unchecked Sendable {}
extension ServerToClient: @unchecked Sendable {}
extension WorldAttributes: @unchecked Sendable {}
extension WorldAttribute: @unchecked Sendable {}
extension EventSubgroupProtobuf: @unchecked Sendable {}
extension RiderAttributes: @unchecked Sendable {}
extension RiderAttributes.AttributeMessage: @unchecked Sendable {}
extension Profiles: @unchecked Sendable {}
extension Profile: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PlayerState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PlayerState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "worldTime"),
    3: .same(proto: "distance"),
    4: .same(proto: "roadTime"),
    5: .same(proto: "laps"),
    6: .same(proto: "speed"),
    8: .same(proto: "roadPosition"),
    9: .same(proto: "cadenceUHz"),
    11: .same(proto: "heartrate"),
    12: .same(proto: "power"),
    13: .same(proto: "heading"),
    14: .same(proto: "lean"),
    15: .same(proto: "climbing"),
    16: .same(proto: "time"),
    19: .same(proto: "f19"),
    20: .same(proto: "f20"),
    21: .same(proto: "progress"),
    22: .same(proto: "customisationId"),
    23: .same(proto: "justWatching"),
    24: .same(proto: "calories"),
    25: .same(proto: "x"),
    26: .same(proto: "altitude"),
    27: .same(proto: "y"),
    28: .same(proto: "watchingRiderId"),
    29: .same(proto: "groupId"),
    31: .same(proto: "sport"),
  ]

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _worldTime: Int64 = 0
    var _distance: Int32 = 0
    var _roadTime: Int32 = 0
    var _laps: Int32 = 0
    var _speed: Int32 = 0
    var _roadPosition: Int32 = 0
    var _cadenceUhz: Int32 = 0
    var _heartrate: Int32 = 0
    var _power: Int32 = 0
    var _heading: Int64 = 0
    var _lean: Int32 = 0
    var _climbing: Int32 = 0
    var _time: Int32 = 0
    var _f19: Int32 = 0
    var _f20: Int32 = 0
    var _progress: Int32 = 0
    var _customisationID: Int64 = 0
    var _justWatching: Int32 = 0
    var _calories: Int32 = 0
    var _x: Float = 0
    var _altitude: Float = 0
    var _y: Float = 0
    var _watchingRiderID: Int32 = 0
    var _groupID: Int32 = 0
    var _sport: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _worldTime = source._worldTime
      _distance = source._distance
      _roadTime = source._roadTime
      _laps = source._laps
      _speed = source._speed
      _roadPosition = source._roadPosition
      _cadenceUhz = source._cadenceUhz
      _heartrate = source._heartrate
      _power = source._power
      _heading = source._heading
      _lean = source._lean
      _climbing = source._climbing
      _time = source._time
      _f19 = source._f19
      _f20 = source._f20
      _progress = source._progress
      _customisationID = source._customisationID
      _justWatching = source._justWatching
      _calories = source._calories
      _x = source._x
      _altitude = source._altitude
      _y = source._y
      _watchingRiderID = source._watchingRiderID
      _groupID = source._groupID
      _sport = source._sport
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._worldTime) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._distance) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._roadTime) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._laps) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._speed) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._roadPosition) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._cadenceUhz) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._heartrate) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._power) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._heading) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._lean) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._climbing) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._time) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._f19) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._f20) }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._progress) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._customisationID) }()
        case 23: try { try decoder.decodeSingularInt32Field(value: &_storage._justWatching) }()
        case 24: try { try decoder.decodeSingularInt32Field(value: &_storage._calories) }()
        case 25: try { try decoder.decodeSingularFloatField(value: &_storage._x) }()
        case 26: try { try decoder.decodeSingularFloatField(value: &_storage._altitude) }()
        case 27: try { try decoder.decodeSingularFloatField(value: &_storage._y) }()
        case 28: try { try decoder.decodeSingularInt32Field(value: &_storage._watchingRiderID) }()
        case 29: try { try decoder.decodeSingularInt32Field(value: &_storage._groupID) }()
        case 31: try { try decoder.decodeSingularInt64Field(value: &_storage._sport) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._worldTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._worldTime, fieldNumber: 2)
      }
      if _storage._distance != 0 {
        try visitor.visitSingularInt32Field(value: _storage._distance, fieldNumber: 3)
      }
      if _storage._roadTime != 0 {
        try visitor.visitSingularInt32Field(value: _storage._roadTime, fieldNumber: 4)
      }
      if _storage._laps != 0 {
        try visitor.visitSingularInt32Field(value: _storage._laps, fieldNumber: 5)
      }
      if _storage._speed != 0 {
        try visitor.visitSingularInt32Field(value: _storage._speed, fieldNumber: 6)
      }
      if _storage._roadPosition != 0 {
        try visitor.visitSingularInt32Field(value: _storage._roadPosition, fieldNumber: 8)
      }
      if _storage._cadenceUhz != 0 {
        try visitor.visitSingularInt32Field(value: _storage._cadenceUhz, fieldNumber: 9)
      }
      if _storage._heartrate != 0 {
        try visitor.visitSingularInt32Field(value: _storage._heartrate, fieldNumber: 11)
      }
      if _storage._power != 0 {
        try visitor.visitSingularInt32Field(value: _storage._power, fieldNumber: 12)
      }
      if _storage._heading != 0 {
        try visitor.visitSingularInt64Field(value: _storage._heading, fieldNumber: 13)
      }
      if _storage._lean != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lean, fieldNumber: 14)
      }
      if _storage._climbing != 0 {
        try visitor.visitSingularInt32Field(value: _storage._climbing, fieldNumber: 15)
      }
      if _storage._time != 0 {
        try visitor.visitSingularInt32Field(value: _storage._time, fieldNumber: 16)
      }
      if _storage._f19 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f19, fieldNumber: 19)
      }
      if _storage._f20 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._f20, fieldNumber: 20)
      }
      if _storage._progress != 0 {
        try visitor.visitSingularInt32Field(value: _storage._progress, fieldNumber: 21)
      }
      if _storage._customisationID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._customisationID, fieldNumber: 22)
      }
      if _storage._justWatching != 0 {
        try visitor.visitSingularInt32Field(value: _storage._justWatching, fieldNumber: 23)
      }
      if _storage._calories != 0 {
        try visitor.visitSingularInt32Field(value: _storage._calories, fieldNumber: 24)
      }
      if _storage._x != 0 {
        try visitor.visitSingularFloatField(value: _storage._x, fieldNumber: 25)
      }
      if _storage._altitude != 0 {
        try visitor.visitSingularFloatField(value: _storage._altitude, fieldNumber: 26)
      }
      if _storage._y != 0 {
        try visitor.visitSingularFloatField(value: _storage._y, fieldNumber: 27)
      }
      if _storage._watchingRiderID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._watchingRiderID, fieldNumber: 28)
      }
      if _storage._groupID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._groupID, fieldNumber: 29)
      }
      if _storage._sport != 0 {
        try visitor.visitSingularInt64Field(value: _storage._sport, fieldNumber: 31)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PlayerState, rhs: PlayerState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._worldTime != rhs_storage._worldTime {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._roadTime != rhs_storage._roadTime {return false}
        if _storage._laps != rhs_storage._laps {return false}
        if _storage._speed != rhs_storage._speed {return false}
        if _storage._roadPosition != rhs_storage._roadPosition {return false}
        if _storage._cadenceUhz != rhs_storage._cadenceUhz {return false}
        if _storage._heartrate != rhs_storage._heartrate {return false}
        if _storage._power != rhs_storage._power {return false}
        if _storage._heading != rhs_storage._heading {return false}
        if _storage._lean != rhs_storage._lean {return false}
        if _storage._climbing != rhs_storage._climbing {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._f19 != rhs_storage._f19 {return false}
        if _storage._f20 != rhs_storage._f20 {return false}
        if _storage._progress != rhs_storage._progress {return false}
        if _storage._customisationID != rhs_storage._customisationID {return false}
        if _storage._justWatching != rhs_storage._justWatching {return false}
        if _storage._calories != rhs_storage._calories {return false}
        if _storage._x != rhs_storage._x {return false}
        if _storage._altitude != rhs_storage._altitude {return false}
        if _storage._y != rhs_storage._y {return false}
        if _storage._watchingRiderID != rhs_storage._watchingRiderID {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._sport != rhs_storage._sport {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientToServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientToServer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connected"),
    2: .standard(proto: "rider_id"),
    3: .standard(proto: "world_time"),
    7: .same(proto: "state"),
    4: .same(proto: "seqno"),
    8: .same(proto: "tag8"),
    9: .same(proto: "tag9"),
    10: .standard(proto: "last_update"),
    11: .same(proto: "tag11"),
    12: .standard(proto: "last_player_update"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.connected) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.riderID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.worldTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.seqno) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.tag8) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.tag9) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.lastUpdate) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.tag11) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.lastPlayerUpdate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.connected != 0 {
      try visitor.visitSingularInt32Field(value: self.connected, fieldNumber: 1)
    }
    if self.riderID != 0 {
      try visitor.visitSingularInt32Field(value: self.riderID, fieldNumber: 2)
    }
    if self.worldTime != 0 {
      try visitor.visitSingularInt64Field(value: self.worldTime, fieldNumber: 3)
    }
    if self.seqno != 0 {
      try visitor.visitSingularInt32Field(value: self.seqno, fieldNumber: 4)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.tag8 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag8, fieldNumber: 8)
    }
    if self.tag9 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag9, fieldNumber: 9)
    }
    if self.lastUpdate != 0 {
      try visitor.visitSingularInt64Field(value: self.lastUpdate, fieldNumber: 10)
    }
    if self.tag11 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag11, fieldNumber: 11)
    }
    if self.lastPlayerUpdate != 0 {
      try visitor.visitSingularInt64Field(value: self.lastPlayerUpdate, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClientToServer, rhs: ClientToServer) -> Bool {
    if lhs.connected != rhs.connected {return false}
    if lhs.riderID != rhs.riderID {return false}
    if lhs.worldTime != rhs.worldTime {return false}
    if lhs._state != rhs._state {return false}
    if lhs.seqno != rhs.seqno {return false}
    if lhs.tag8 != rhs.tag8 {return false}
    if lhs.tag9 != rhs.tag9 {return false}
    if lhs.lastUpdate != rhs.lastUpdate {return false}
    if lhs.tag11 != rhs.tag11 {return false}
    if lhs.lastPlayerUpdate != rhs.lastPlayerUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SegmentResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SegmentResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "rider_id"),
    6: .standard(proto: "event_subgroup_id"),
    7: .standard(proto: "first_name"),
    8: .standard(proto: "last_name"),
    10: .standard(proto: "finish_time_str"),
    11: .standard(proto: "elapsed_ms"),
    12: .same(proto: "powermeter"),
    13: .same(proto: "weight"),
    15: .same(proto: "power"),
    19: .same(proto: "heartrate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.riderID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.eventSubgroupID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.firstName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.lastName) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.finishTimeStr) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.elapsedMs) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.powermeter) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.weight) }()
      case 15: try { try decoder.decodeSingularInt32Field(value: &self.power) }()
      case 19: try { try decoder.decodeSingularInt32Field(value: &self.heartrate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.riderID != 0 {
      try visitor.visitSingularInt64Field(value: self.riderID, fieldNumber: 2)
    }
    if self.eventSubgroupID != 0 {
      try visitor.visitSingularInt64Field(value: self.eventSubgroupID, fieldNumber: 6)
    }
    if !self.firstName.isEmpty {
      try visitor.visitSingularStringField(value: self.firstName, fieldNumber: 7)
    }
    if !self.lastName.isEmpty {
      try visitor.visitSingularStringField(value: self.lastName, fieldNumber: 8)
    }
    if !self.finishTimeStr.isEmpty {
      try visitor.visitSingularStringField(value: self.finishTimeStr, fieldNumber: 10)
    }
    if self.elapsedMs != 0 {
      try visitor.visitSingularInt64Field(value: self.elapsedMs, fieldNumber: 11)
    }
    if self.powermeter != 0 {
      try visitor.visitSingularInt32Field(value: self.powermeter, fieldNumber: 12)
    }
    if self.weight != 0 {
      try visitor.visitSingularInt32Field(value: self.weight, fieldNumber: 13)
    }
    if self.power != 0 {
      try visitor.visitSingularInt32Field(value: self.power, fieldNumber: 15)
    }
    if self.heartrate != 0 {
      try visitor.visitSingularInt32Field(value: self.heartrate, fieldNumber: 19)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SegmentResult, rhs: SegmentResult) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.riderID != rhs.riderID {return false}
    if lhs.eventSubgroupID != rhs.eventSubgroupID {return false}
    if lhs.firstName != rhs.firstName {return false}
    if lhs.lastName != rhs.lastName {return false}
    if lhs.finishTimeStr != rhs.finishTimeStr {return false}
    if lhs.elapsedMs != rhs.elapsedMs {return false}
    if lhs.powermeter != rhs.powermeter {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.power != rhs.power {return false}
    if lhs.heartrate != rhs.heartrate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SegmentResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SegmentResults"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "world_id"),
    2: .standard(proto: "segment_id"),
    3: .standard(proto: "event_subgroup_id"),
    4: .standard(proto: "segment_results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.worldID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.segmentID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.eventSubgroupID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.segmentResults) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.worldID != 0 {
      try visitor.visitSingularInt64Field(value: self.worldID, fieldNumber: 1)
    }
    if self.segmentID != 0 {
      try visitor.visitSingularInt64Field(value: self.segmentID, fieldNumber: 2)
    }
    if self.eventSubgroupID != 0 {
      try visitor.visitSingularInt64Field(value: self.eventSubgroupID, fieldNumber: 3)
    }
    if !self.segmentResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segmentResults, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SegmentResults, rhs: SegmentResults) -> Bool {
    if lhs.worldID != rhs.worldID {return false}
    if lhs.segmentID != rhs.segmentID {return false}
    if lhs.eventSubgroupID != rhs.eventSubgroupID {return false}
    if lhs.segmentResults != rhs.segmentResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UnknownMessage1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UnknownMessage1"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UnknownMessage1, rhs: UnknownMessage1) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UnknownMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UnknownMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UnknownMessage, rhs: UnknownMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServerToClient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ServerToClient"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag1"),
    2: .standard(proto: "rider_id"),
    3: .standard(proto: "world_time"),
    4: .same(proto: "seqno"),
    8: .standard(proto: "player_states"),
    9: .standard(proto: "player_updates"),
    11: .same(proto: "tag11"),
    17: .same(proto: "tag17"),
    18: .standard(proto: "num_msgs"),
    19: .same(proto: "msgnum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.tag1) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.riderID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.worldTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.seqno) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.playerStates) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.playerUpdates) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.tag11) }()
      case 17: try { try decoder.decodeSingularInt64Field(value: &self.tag17) }()
      case 18: try { try decoder.decodeSingularInt32Field(value: &self.numMsgs) }()
      case 19: try { try decoder.decodeSingularInt32Field(value: &self.msgnum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tag1 != 0 {
      try visitor.visitSingularInt32Field(value: self.tag1, fieldNumber: 1)
    }
    if self.riderID != 0 {
      try visitor.visitSingularInt32Field(value: self.riderID, fieldNumber: 2)
    }
    if self.worldTime != 0 {
      try visitor.visitSingularInt64Field(value: self.worldTime, fieldNumber: 3)
    }
    if self.seqno != 0 {
      try visitor.visitSingularInt32Field(value: self.seqno, fieldNumber: 4)
    }
    if !self.playerStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.playerStates, fieldNumber: 8)
    }
    if !self.playerUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.playerUpdates, fieldNumber: 9)
    }
    if self.tag11 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag11, fieldNumber: 11)
    }
    if self.tag17 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag17, fieldNumber: 17)
    }
    if self.numMsgs != 0 {
      try visitor.visitSingularInt32Field(value: self.numMsgs, fieldNumber: 18)
    }
    if self.msgnum != 0 {
      try visitor.visitSingularInt32Field(value: self.msgnum, fieldNumber: 19)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ServerToClient, rhs: ServerToClient) -> Bool {
    if lhs.tag1 != rhs.tag1 {return false}
    if lhs.riderID != rhs.riderID {return false}
    if lhs.worldTime != rhs.worldTime {return false}
    if lhs.seqno != rhs.seqno {return false}
    if lhs.playerStates != rhs.playerStates {return false}
    if lhs.playerUpdates != rhs.playerUpdates {return false}
    if lhs.tag11 != rhs.tag11 {return false}
    if lhs.tag17 != rhs.tag17 {return false}
    if lhs.numMsgs != rhs.numMsgs {return false}
    if lhs.msgnum != rhs.msgnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WorldAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WorldAttributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "world_id"),
    2: .same(proto: "name"),
    3: .same(proto: "tag3"),
    4: .same(proto: "tag5"),
    6: .standard(proto: "world_time"),
    7: .standard(proto: "clock_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.worldID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.tag3) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.tag5) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.worldTime) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.clockTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.worldID != 0 {
      try visitor.visitSingularInt32Field(value: self.worldID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.tag3 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag3, fieldNumber: 3)
    }
    if self.tag5 != 0 {
      try visitor.visitSingularInt64Field(value: self.tag5, fieldNumber: 4)
    }
    if self.worldTime != 0 {
      try visitor.visitSingularInt64Field(value: self.worldTime, fieldNumber: 6)
    }
    if self.clockTime != 0 {
      try visitor.visitSingularInt64Field(value: self.clockTime, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WorldAttributes, rhs: WorldAttributes) -> Bool {
    if lhs.worldID != rhs.worldID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.tag3 != rhs.tag3 {return false}
    if lhs.tag5 != rhs.tag5 {return false}
    if lhs.worldTime != rhs.worldTime {return false}
    if lhs.clockTime != rhs.clockTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WorldAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WorldAttribute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "world_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.worldTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.worldTime != 0 {
      try visitor.visitSingularInt64Field(value: self.worldTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WorldAttribute, rhs: WorldAttribute) -> Bool {
    if lhs.worldTime != rhs.worldTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventSubgroupProtobuf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EventSubgroupProtobuf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    8: .same(proto: "rules"),
    22: .same(proto: "route"),
    25: .same(proto: "laps"),
    29: .same(proto: "startLocation"),
    30: .same(proto: "label"),
    31: .same(proto: "paceType"),
    36: .same(proto: "jerseyHash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.rules) }()
      case 22: try { try decoder.decodeSingularInt32Field(value: &self.route) }()
      case 25: try { try decoder.decodeSingularInt32Field(value: &self.laps) }()
      case 29: try { try decoder.decodeSingularInt32Field(value: &self.startLocation) }()
      case 30: try { try decoder.decodeSingularInt32Field(value: &self.label) }()
      case 31: try { try decoder.decodeSingularInt32Field(value: &self.paceType) }()
      case 36: try { try decoder.decodeSingularInt32Field(value: &self.jerseyHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.rules != 0 {
      try visitor.visitSingularInt32Field(value: self.rules, fieldNumber: 8)
    }
    if self.route != 0 {
      try visitor.visitSingularInt32Field(value: self.route, fieldNumber: 22)
    }
    if self.laps != 0 {
      try visitor.visitSingularInt32Field(value: self.laps, fieldNumber: 25)
    }
    if self.startLocation != 0 {
      try visitor.visitSingularInt32Field(value: self.startLocation, fieldNumber: 29)
    }
    if self.label != 0 {
      try visitor.visitSingularInt32Field(value: self.label, fieldNumber: 30)
    }
    if self.paceType != 0 {
      try visitor.visitSingularInt32Field(value: self.paceType, fieldNumber: 31)
    }
    if self.jerseyHash != 0 {
      try visitor.visitSingularInt32Field(value: self.jerseyHash, fieldNumber: 36)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EventSubgroupProtobuf, rhs: EventSubgroupProtobuf) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.route != rhs.route {return false}
    if lhs.laps != rhs.laps {return false}
    if lhs.startLocation != rhs.startLocation {return false}
    if lhs.label != rhs.label {return false}
    if lhs.paceType != rhs.paceType {return false}
    if lhs.jerseyHash != rhs.jerseyHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RiderAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RiderAttributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "f2"),
    3: .same(proto: "f3"),
    4: .same(proto: "attributeMessage"),
    10: .same(proto: "theirId"),
    13: .same(proto: "f13"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.f2) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.f3) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._attributeMessage) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.theirID) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.f13) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.f2 != 0 {
      try visitor.visitSingularInt32Field(value: self.f2, fieldNumber: 2)
    }
    if self.f3 != 0 {
      try visitor.visitSingularInt32Field(value: self.f3, fieldNumber: 3)
    }
    try { if let v = self._attributeMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.theirID != 0 {
      try visitor.visitSingularInt32Field(value: self.theirID, fieldNumber: 10)
    }
    if self.f13 != 0 {
      try visitor.visitSingularInt32Field(value: self.f13, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RiderAttributes, rhs: RiderAttributes) -> Bool {
    if lhs.f2 != rhs.f2 {return false}
    if lhs.f3 != rhs.f3 {return false}
    if lhs._attributeMessage != rhs._attributeMessage {return false}
    if lhs.theirID != rhs.theirID {return false}
    if lhs.f13 != rhs.f13 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RiderAttributes.AttributeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RiderAttributes.protoMessageName + ".AttributeMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "myId"),
    2: .same(proto: "theirId"),
    3: .same(proto: "firstName"),
    4: .same(proto: "lastName"),
    5: .same(proto: "countryCode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.myID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.theirID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.firstName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.lastName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.countryCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.myID != 0 {
      try visitor.visitSingularInt32Field(value: self.myID, fieldNumber: 1)
    }
    if self.theirID != 0 {
      try visitor.visitSingularInt32Field(value: self.theirID, fieldNumber: 2)
    }
    if !self.firstName.isEmpty {
      try visitor.visitSingularStringField(value: self.firstName, fieldNumber: 3)
    }
    if !self.lastName.isEmpty {
      try visitor.visitSingularStringField(value: self.lastName, fieldNumber: 4)
    }
    if self.countryCode != 0 {
      try visitor.visitSingularInt32Field(value: self.countryCode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RiderAttributes.AttributeMessage, rhs: RiderAttributes.AttributeMessage) -> Bool {
    if lhs.myID != rhs.myID {return false}
    if lhs.theirID != rhs.theirID {return false}
    if lhs.firstName != rhs.firstName {return false}
    if lhs.lastName != rhs.lastName {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Profiles"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profiles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.profiles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.profiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.profiles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profiles, rhs: Profiles) -> Bool {
    if lhs.profiles != rhs.profiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Profile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    4: .same(proto: "firstName"),
    5: .same(proto: "lastName"),
    6: .same(proto: "male"),
    9: .same(proto: "weight"),
    12: .same(proto: "bodyType"),
    34: .same(proto: "countryCode"),
    35: .same(proto: "totalDistance"),
    36: .same(proto: "totalDistanceClimbed"),
    37: .same(proto: "totalTimeInMinutes"),
    41: .same(proto: "totalWattHours"),
    42: .same(proto: "height"),
    46: .same(proto: "totalExperiencePoints"),
    49: .same(proto: "achievementLevel"),
    52: .same(proto: "powerSource"),
    55: .same(proto: "age"),
    108: .same(proto: "launchedGameClient"),
    109: .same(proto: "currentActivityId"),
  ]

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _firstName: String = String()
    var _lastName: String = String()
    var _male: Int32 = 0
    var _weight: Int32 = 0
    var _bodyType: Int32 = 0
    var _countryCode: Int32 = 0
    var _totalDistance: Int32 = 0
    var _totalDistanceClimbed: Int32 = 0
    var _totalTimeInMinutes: Int32 = 0
    var _totalWattHours: Int32 = 0
    var _height: Int32 = 0
    var _totalExperiencePoints: Int32 = 0
    var _achievementLevel: Int32 = 0
    var _powerSource: Int32 = 0
    var _age: Int32 = 0
    var _launchedGameClient: String = String()
    var _currentActivityID: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _firstName = source._firstName
      _lastName = source._lastName
      _male = source._male
      _weight = source._weight
      _bodyType = source._bodyType
      _countryCode = source._countryCode
      _totalDistance = source._totalDistance
      _totalDistanceClimbed = source._totalDistanceClimbed
      _totalTimeInMinutes = source._totalTimeInMinutes
      _totalWattHours = source._totalWattHours
      _height = source._height
      _totalExperiencePoints = source._totalExperiencePoints
      _achievementLevel = source._achievementLevel
      _powerSource = source._powerSource
      _age = source._age
      _launchedGameClient = source._launchedGameClient
      _currentActivityID = source._currentActivityID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._firstName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._lastName) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._male) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._weight) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._bodyType) }()
        case 34: try { try decoder.decodeSingularInt32Field(value: &_storage._countryCode) }()
        case 35: try { try decoder.decodeSingularInt32Field(value: &_storage._totalDistance) }()
        case 36: try { try decoder.decodeSingularInt32Field(value: &_storage._totalDistanceClimbed) }()
        case 37: try { try decoder.decodeSingularInt32Field(value: &_storage._totalTimeInMinutes) }()
        case 41: try { try decoder.decodeSingularInt32Field(value: &_storage._totalWattHours) }()
        case 42: try { try decoder.decodeSingularInt32Field(value: &_storage._height) }()
        case 46: try { try decoder.decodeSingularInt32Field(value: &_storage._totalExperiencePoints) }()
        case 49: try { try decoder.decodeSingularInt32Field(value: &_storage._achievementLevel) }()
        case 52: try { try decoder.decodeSingularInt32Field(value: &_storage._powerSource) }()
        case 55: try { try decoder.decodeSingularInt32Field(value: &_storage._age) }()
        case 108: try { try decoder.decodeSingularStringField(value: &_storage._launchedGameClient) }()
        case 109: try { try decoder.decodeSingularInt32Field(value: &_storage._currentActivityID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._firstName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._firstName, fieldNumber: 4)
      }
      if !_storage._lastName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastName, fieldNumber: 5)
      }
      if _storage._male != 0 {
        try visitor.visitSingularInt32Field(value: _storage._male, fieldNumber: 6)
      }
      if _storage._weight != 0 {
        try visitor.visitSingularInt32Field(value: _storage._weight, fieldNumber: 9)
      }
      if _storage._bodyType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._bodyType, fieldNumber: 12)
      }
      if _storage._countryCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._countryCode, fieldNumber: 34)
      }
      if _storage._totalDistance != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalDistance, fieldNumber: 35)
      }
      if _storage._totalDistanceClimbed != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalDistanceClimbed, fieldNumber: 36)
      }
      if _storage._totalTimeInMinutes != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalTimeInMinutes, fieldNumber: 37)
      }
      if _storage._totalWattHours != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalWattHours, fieldNumber: 41)
      }
      if _storage._height != 0 {
        try visitor.visitSingularInt32Field(value: _storage._height, fieldNumber: 42)
      }
      if _storage._totalExperiencePoints != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalExperiencePoints, fieldNumber: 46)
      }
      if _storage._achievementLevel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._achievementLevel, fieldNumber: 49)
      }
      if _storage._powerSource != 0 {
        try visitor.visitSingularInt32Field(value: _storage._powerSource, fieldNumber: 52)
      }
      if _storage._age != 0 {
        try visitor.visitSingularInt32Field(value: _storage._age, fieldNumber: 55)
      }
      if !_storage._launchedGameClient.isEmpty {
        try visitor.visitSingularStringField(value: _storage._launchedGameClient, fieldNumber: 108)
      }
      if _storage._currentActivityID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._currentActivityID, fieldNumber: 109)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profile, rhs: Profile) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._firstName != rhs_storage._firstName {return false}
        if _storage._lastName != rhs_storage._lastName {return false}
        if _storage._male != rhs_storage._male {return false}
        if _storage._weight != rhs_storage._weight {return false}
        if _storage._bodyType != rhs_storage._bodyType {return false}
        if _storage._countryCode != rhs_storage._countryCode {return false}
        if _storage._totalDistance != rhs_storage._totalDistance {return false}
        if _storage._totalDistanceClimbed != rhs_storage._totalDistanceClimbed {return false}
        if _storage._totalTimeInMinutes != rhs_storage._totalTimeInMinutes {return false}
        if _storage._totalWattHours != rhs_storage._totalWattHours {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._totalExperiencePoints != rhs_storage._totalExperiencePoints {return false}
        if _storage._achievementLevel != rhs_storage._achievementLevel {return false}
        if _storage._powerSource != rhs_storage._powerSource {return false}
        if _storage._age != rhs_storage._age {return false}
        if _storage._launchedGameClient != rhs_storage._launchedGameClient {return false}
        if _storage._currentActivityID != rhs_storage._currentActivityID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
