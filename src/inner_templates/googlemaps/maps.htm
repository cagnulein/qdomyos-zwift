<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Include the CesiumJS JavaScript and CSS files -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.94/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.94/Build/Cesium/Widgets/widgets.css" rel="stylesheet">  
  <script src="jquery-3.6.0.min.js"></script>
  <script src="chartjs.3.4.1.min.js"></script>
  <script src="chart.js"></script>
  <script src="globals.js"></script>
  <script src="bike.js"></script>
  <script src="main_ws_manager.js"></script>
  <script src="cesium-key.js"></script>
  <style>
  canvas{
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
  }
  </style>
</head>
<body>
  <div id="cesiumContainer" style="display: block;
  position: absolute;
  top: 0;
  left: 0;
  border: none;
  width: 100%;
  height: 100%;"></div>
  <script>    
    // Initialize the Cesium Viewer in the HTML element with the `cesiumContainer` ID.
    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrainProvider: Cesium.createWorldTerrain()
    });

    $('.cesium-viewer-animationContainer').css("visibility", "hidden");
	 $('.cesium-viewer-bottom').css("visibility", "hidden");
	 $('.cesium-viewer-timelineContainer').css("visibility", "hidden");
	 $('.cesium-viewer-fullscreenContainer').css("visibility", "hidden");


    viewer.scene.globe.enableLighting = true;
	 viewer.scene.fog.enabled = true;
    viewer.scene.globe.depthTestAgainstTerrain = true;
    // Add Cesium OSM Buildings, a global 3D buildings layer.
    //const buildingTileset = viewer.scene.primitives.add(Cesium.createOsmBuildings());
         var center = Cesium.Cartesian3.fromDegrees(10.855092, 44.508273);
	 var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
	 let map = viewer;

// Add our vehicle model.
const bike = viewer.entities.add({
  position: center,
  model: {
    uri: bikeUri,
    runAnimations: false,
          minimumPixelSize: 32,
          scale: 0.5,
          color: Cesium.Color.ORANGE,
          silhouetteColor: Cesium.Color.ORANGE,
          silhouetteSize: 1,
  },

});

viewer.trackedEntity = bike;

  </script>
 </div>
</body>
  <body>
    <div id="cesiumContainer" class="cesiumContainer"></div>
	 <div id="metricsContainer" style="position: absolute; bottom: 0px; right: 0px; width: 200px; height: 250px; touch-action: none; user-select: none;">
        <div class="metrics" style="color: #FFFFFF; width: 100%; height: 100%; margin: 0; border-radius: 25px; border: 2px solid #73AD21; background: #73AD21; padding: 8px; box-sizing: border-box; overflow: hidden; position: relative;">
            <div id="metricsText" style="font-size: 12px; line-height: 1.4;">üèÉSpeed: 0.00<br>üö¥Cadence:0<br>üíìHeart:0<br>üî•Calories:0.0<br>üìèOdometer:0.00<br>‚ö°Watt:0<br>‚è≤Ô∏èElapsed:0:00:00<br>üìêInclination:0.0<br>üß≤Resistance:0<br>‚úàÔ∏èAltitude:0.0<br>‚õ∞Ô∏èElevation:0.0</div>
            <div id="resizeHandle" style="position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; background: linear-gradient(135deg, transparent 50%, rgba(255,255,255,0.5) 50%); cursor: nwse-resize; border-bottom-right-radius: 23px;"></div>
        </div>
    </div>
	      <div style="border: 0px solid #aaa; border-radius: 10px; overflow: hidden; position:absolute; bottom: 0px; right: 150px; width=150px; height=75px"><canvas id="canvasChart" style="width=150px; height=75px; border-right: 0pt solid #ffff00;"></canvas></div>
    <script type="text/javascript">
    let cameraComplete = true
    let lastAzimuth = 0
    let lastAlt = 0
    let lastLat = 0
    let lastLon = 0
    let refreshRate = 25
    let currentSpeed = 0
    let lastCoordinateTS = 0
    let altOffset = 0
    let lastBikeHeight = 0
    let firstTime = 0

    function a() {
    onWorkout = false;
    let el = new MainWSQueueElement({
        msg: 'getlatlon'
    }, function(msg) {
        if (msg.msg === 'R_getlatlon') {
            return msg.content;
        }
        return null;
    }, 15000, 3);
    el.enqueue().then(process_latlon);
    keys_arr = ['speed', 'cadence', 'heart', 'calories', 'distance', 'watts', 'elapsed_h', 'elapsed_m', 'elapsed_s', 'inclination', 'resistance', 'elevation', 'altitude']
         let ell = new MainWSQueueElement({
	     msg: null,
		}, function(msg) {
		  if (msg.msg === 'workout') {
		      var speed = 0;
				var cadence = 0;
				var hr = 0;
				var calories = 0;
				var odometer = 0;
				var watt = 0;
				var elapsed_h = 0;
				var elapsed_m = 0;
				var elapsed_s = 0;
				var inclination = 0;
				var resistance = 0;
				var elevation = 0;
				var altitude = 0;
				for (let key of keys_arr) {
				    if (msg.content[key] === undefined)
                                             continue;
						if (key === 'speed') {
                                                  currentSpeed = speed = msg.content[key];
						} else if (key === 'cadence') {
						  cadence = msg.content[key];
						} else if (key === 'heart') {
                                                  hr = msg.content[key];
						} else if (key === 'calories') {
                                                  calories = msg.content[key];
						} else if (key === 'distance') {
                                                  odometer = msg.content[key];
						} else if (key === 'watts') {
                                                  watt = msg.content[key];
						} else if (key === 'elapsed_h') {
                                                  elapsed_h = msg.content[key];
						} else if (key === 'elapsed_m') {
                                                  elapsed_m = msg.content[key];
						} else if (key === 'elapsed_s') {
                                                  elapsed_s = msg.content[key];
						} else if (key === 'inclination') {
                                                  inclination = msg.content[key];
						} else if (key === 'resistance') {
                                                  resistance = msg.content[key];
						} else if (key === 'elevation') {
                                                  elevation = msg.content[key];
																} else if (key === 'altitude') {
																  altitude = msg.content[key];
																}
				}

            $('#metricsText').html("üèÉSpeed: " + speed.toFixed(2) + "<br>üö¥Cadence:" + cadence.toFixed(0) + "<br>üíìHeart:"+ hr.toFixed(0) + "<br>üî•Calories:"+ calories.toFixed(1) + "<br>üìèOdometer:"+ odometer.toFixed(2) + "<br>‚ö°Watt:"+ watt.toFixed(0) + "<br>‚è≤Ô∏èElapsed:"+ elapsed_h.toString().padStart(2, "0") + ":" + elapsed_m.toString().padStart(2, "0") + ":"+ elapsed_s.toString().padStart(2, "0") + "<br>üìêInclination:"+ inclination.toFixed(1) + "<br>üß≤Resistance:"+ resistance.toFixed(0) + "<br>‚úàÔ∏èAltitude:"+ altitude.toFixed(1) + "<br>‚õ∞Ô∏èElevation:"+ elevation.toFixed(2));
		  }
		  return null;
		}, 15000, 3);
         ell.enqueue().then(onWorkout).catch(function(err) {
	     console.error('Error is ' + err);
                });
    }

    function camera_complete() {
        cameraComplete = true;
    }

    function easing_function(time) {
        return time;
    }

    function  process_latlon(msg) {

    if(firstTime==0)
        viewer.camera.zoomOut(200);
    firstTime=1;


	 /*if(!cameraComplete) return;*/
    cameraComplete = false;
    let lat = parseFloat(msg.split(",")[0]);
    let lon = parseFloat(msg.split(",")[1]);
	 let alt = parseFloat(msg.split(",")[2]) + altOffset;
	 let realAzimuth = parseFloat(msg.split(",")[3]);
	 let azimuth = parseFloat(msg.split(",")[4]);
	 let realLat = lat
	 let realLon = lon

    if(lastAlt != alt && Math.abs(lastAlt-alt) < 30) {
        if(lastAlt > alt)
            lastAlt = alt = lastAlt - 0.01;
        else
            lastAlt = alt = lastAlt + 0.01;
    } else {
        lastAlt = alt;
    }
    if(Math.abs(lastAlt - alt) < 0.01)
        lastAlt = alt;


   const length = 2;

   const startLon = Cesium.Math.toRadians(realLon);
	const endLon = Cesium.Math.toRadians(realLon + 0.000001);

   const startLat = Cesium.Math.toRadians(realLat);

   const terrainSamplePositions = [];
   let i
        for (i = 0; i < length; ++i) {
	  const lonL = Cesium.Math.lerp(
	    endLon,
		 startLon,
		 i / (length - 1)
	  );
	  const position = new Cesium.Cartographic(lonL, startLat);
	  terrainSamplePositions.push(position);
	  }

    bike.position = Cesium.Cartesian3.fromDegrees(realLon, realLat, lastBikeHeight);
    bike.orientation = Cesium.Transforms.headingPitchRollQuaternion(Cesium.Cartesian3.fromDegrees(realLon, realLat), new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(realAzimuth), 0, 0));

Promise.resolve(
       Cesium.sampleTerrainMostDetailed(
         viewer.terrainProvider,
              terrainSamplePositions
       )
       ).then(function (samples) {
       const hpr = new Cesium.HeadingPitchRoll(
         Cesium.Math.toRadians(realAzimuth),
              0,
              0
       );
           lastBikeHeight = samples[0].height
           //bike.modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(Cesium.Cartesian3.fromDegrees(realLon, realLat, lastBikeHeight), hpr);
       });


         setTimeout(a,refreshRate);

                }
					function process_gpxbase64(msg) {
	  viewer.dataSources
	            .add(
					  Cesium.GpxDataSource.load(
                                            msg,
						 {
						   clampToGround: true,
							}
						)).then(function(dataSource) {
							// Add start and end markers
							const entities = dataSource.entities.values;
							if (entities.length > 0) {
								// Find the polyline entity (the track)
								const track = entities.find(entity => entity.polyline);
								if (track && track.polyline.positions) {
									const positions = track.polyline.positions.getValue();
									if (positions.length > 0) {
										// Add start marker (green) - elevated 45m above ground
										const startPos = Cesium.Cartographic.fromCartesian(positions[0]);
										const elevatedStartPos = Cesium.Cartesian3.fromRadians(startPos.longitude, startPos.latitude, startPos.height + 45);
										viewer.entities.add({
											position: elevatedStartPos,
											billboard: {
												image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTYiIGZpbGw9IiMwMEZGMDAiLz4KPHN2ZyB4PSI4IiB5PSI4IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI0ZGRkZGRiI+CjxwYXRoIGQ9Im04IDEyIDQgNCA4LTgiLz4KPC9zdmc+Cjwvc3ZnPgo=',
												scale: 1.0,
												pixelOffset: new Cesium.Cartesian2(0, -16),
												verticalOrigin: Cesium.VerticalOrigin.BOTTOM
											},
											label: {
												text: 'START',
												font: 'bold 14px sans-serif',
												fillColor: Cesium.Color.WHITE,
												outlineColor: Cesium.Color.BLACK,
												outlineWidth: 2,
												style: Cesium.LabelStyle.FILL_AND_OUTLINE,
												pixelOffset: new Cesium.Cartesian2(0, -50),
												verticalOrigin: Cesium.VerticalOrigin.BOTTOM
											}
										});
										
										// Add end marker (red) - elevated 45m above ground
										const endPos = Cesium.Cartographic.fromCartesian(positions[positions.length - 1]);
										const elevatedEndPos = Cesium.Cartesian3.fromRadians(endPos.longitude, endPos.latitude, endPos.height + 45);
										viewer.entities.add({
											position: elevatedEndPos,
											billboard: {
												image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTYiIGZpbGw9IiNGRjAwMDAiLz4KPHN2ZyB4PSI4IiB5PSI4IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI0ZGRkZGRiI+CjxwYXRoIGQ9Ik02IDZoMTJ2MTJINnoiLz4KPC9zdmc+Cjwvc3ZnPgo=',
												scale: 1.0,
												pixelOffset: new Cesium.Cartesian2(0, -16),
												verticalOrigin: Cesium.VerticalOrigin.BOTTOM
											},
											label: {
												text: 'FINISH',
												font: 'bold 14px sans-serif',
												fillColor: Cesium.Color.WHITE,
												outlineColor: Cesium.Color.BLACK,
												outlineWidth: 2,
												style: Cesium.LabelStyle.FILL_AND_OUTLINE,
												pixelOffset: new Cesium.Cartesian2(0, -50),
												verticalOrigin: Cesium.VerticalOrigin.BOTTOM
											}
										});
									}
								}
							}
						});
	  }

let el = new MainWSQueueElement({
msg: 'getgpxbase64'
}, function(msg) {
if (msg.msg === 'R_getgpxbase64') {
return msg.content;
}
return null;
}, 15000, 3);
el.enqueue().then(process_gpxbase64).catch(function(err) {
console.error('Error is ' + err);
});
      setTimeout(a,0);

      // Metrics container drag and resize functionality
      (function() {
          const container = document.getElementById('metricsContainer');
          const resizeHandle = document.getElementById('resizeHandle');
          const metricsText = document.getElementById('metricsText');

          let isDragging = false;
          let isResizing = false;
          let startX, startY, startLeft, startTop, startWidth, startHeight;
          let resizeTimeout = null;

          // Load saved position and size
          function loadState() {
              const saved = localStorage.getItem('metricsContainerState');
              if (saved) {
                  try {
                      const state = JSON.parse(saved);
                      if (state.left !== undefined) container.style.left = state.left + 'px';
                      if (state.top !== undefined) container.style.top = state.top + 'px';
                      if (state.right !== undefined) container.style.right = state.right + 'px';
                      if (state.bottom !== undefined) container.style.bottom = state.bottom + 'px';
                      if (state.width) container.style.width = state.width + 'px';
                      if (state.height) container.style.height = state.height + 'px';
                      updateFontSize();
                  } catch (e) {
                      console.error('Error loading metrics state:', e);
                  }
              }
          }

          // Save position and size
          function saveState() {
              const state = {
                  left: container.offsetLeft,
                  top: container.offsetTop,
                  width: container.offsetWidth,
                  height: container.offsetHeight
              };
              localStorage.setItem('metricsContainerState', JSON.stringify(state));
          }

          // Update font size using binary search to find maximum size that fits
          function updateFontSize() {
              const minFontSize = 6;
              const maxFontSize = 48;
              let low = minFontSize;
              let high = maxFontSize;
              let bestFit = minFontSize;

              // Count number of lines in the content
              function countLines() {
                  const html = metricsText.innerHTML;
                  const brCount = (html.match(/<br>/gi) || []).length;
                  return brCount + 1; // +1 for the first line
              }

              // Check if content fits with current font size
              function contentFits() {
                  // Force reflow
                  void metricsText.offsetHeight;

                  // Get computed line height
                  const computedStyle = window.getComputedStyle(metricsText);
                  const lineHeight = parseFloat(computedStyle.lineHeight);

                  // Calculate total height needed
                  const numLines = countLines();
                  const totalHeightNeeded = numLines * lineHeight;

                  // Get available height (parent's clientHeight minus padding)
                  const metricsDiv = metricsText.parentElement;
                  const parentStyle = window.getComputedStyle(metricsDiv);
                  const paddingTop = parseFloat(parentStyle.paddingTop);
                  const paddingBottom = parseFloat(parentStyle.paddingBottom);
                  const availableHeight = metricsDiv.clientHeight - paddingTop - paddingBottom;

                  // Check if it fits
                  const fitsVertically = totalHeightNeeded <= availableHeight;
                  const fitsHorizontally = metricsText.scrollWidth <= metricsText.clientWidth;

                  return fitsVertically && fitsHorizontally;
              }

              // Binary search for the maximum font size that fits
              while (low <= high) {
                  const mid = Math.floor((low + high) / 2);
                  metricsText.style.fontSize = mid + 'px';

                  if (contentFits()) {
                      bestFit = mid;
                      low = mid + 1; // Try larger
                  } else {
                      high = mid - 1; // Try smaller
                  }
              }

              // Apply the best fit size
              metricsText.style.fontSize = bestFit + 'px';
          }

          // Debounced version of updateFontSize (only during resize)
          function debouncedUpdateFontSize() {
              if (resizeTimeout) {
                  clearTimeout(resizeTimeout);
              }
              resizeTimeout = setTimeout(function() {
                  updateFontSize();
              }, 500);
          }

          // Get touch or mouse coordinates
          function getCoordinates(e) {
              if (e.touches && e.touches.length > 0) {
                  return { x: e.touches[0].clientX, y: e.touches[0].clientY };
              }
              return { x: e.clientX, y: e.clientY };
          }

          // Start dragging
          function startDrag(e) {
              if (isResizing) return;
              isDragging = true;
              const coords = getCoordinates(e);
              startX = coords.x;
              startY = coords.y;
              startLeft = container.offsetLeft;
              startTop = container.offsetTop;
              container.style.right = 'auto';
              container.style.bottom = 'auto';
              e.stopPropagation();
              e.preventDefault();
          }

          // Start resizing
          function startResize(e) {
              isResizing = true;
              const coords = getCoordinates(e);
              startX = coords.x;
              startY = coords.y;
              startWidth = container.offsetWidth;
              startHeight = container.offsetHeight;
              e.stopPropagation();
              e.preventDefault();
          }

          // Handle move
          function handleMove(e) {
              const coords = getCoordinates(e);

              if (isDragging) {
                  const deltaX = coords.x - startX;
                  const deltaY = coords.y - startY;
                  container.style.left = (startLeft + deltaX) + 'px';
                  container.style.top = (startTop + deltaY) + 'px';
                  e.stopPropagation();
                  e.preventDefault();
              } else if (isResizing) {
                  const deltaX = coords.x - startX;
                  const deltaY = coords.y - startY;
                  const newWidth = Math.max(100, startWidth + deltaX);
                  const newHeight = Math.max(100, startHeight + deltaY);
                  container.style.width = newWidth + 'px';
                  container.style.height = newHeight + 'px';
                  debouncedUpdateFontSize();
                  e.stopPropagation();
                  e.preventDefault();
              }
          }

          // End drag or resize
          function endDragOrResize(e) {
              if (isDragging || isResizing) {
                  saveState();
                  // If we were resizing, clear pending timeout and update immediately
                  if (isResizing) {
                      if (resizeTimeout) {
                          clearTimeout(resizeTimeout);
                          resizeTimeout = null;
                      }
                      updateFontSize();
                  }
              }
              isDragging = false;
              isResizing = false;
          }

          // Add event listeners for dragging (on container, but not on resize handle)
          container.addEventListener('mousedown', function(e) {
              if (e.target !== resizeHandle) startDrag(e);
          });
          container.addEventListener('touchstart', function(e) {
              if (e.target !== resizeHandle) startDrag(e);
          }, { passive: false });

          // Add event listeners for resizing (on resize handle)
          resizeHandle.addEventListener('mousedown', startResize);
          resizeHandle.addEventListener('touchstart', startResize, { passive: false });

          // Add global move and end listeners
          document.addEventListener('mousemove', handleMove);
          document.addEventListener('touchmove', handleMove, { passive: false });
          document.addEventListener('mouseup', endDragOrResize);
          document.addEventListener('touchend', endDragOrResize);

          // Load saved state and set initial font size
          loadState();
          updateFontSize();
      })();
    </script>
  </body>
</html>
