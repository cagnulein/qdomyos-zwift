// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Zwift hub.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum BLEReceiver_Zwift_PlayButtonStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case on // = 0
  case off // = 1

  init() {
    self = .on
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .on
    case 1: self = .off
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .on: return 0
    case .off: return 1
    }
  }

}

#if swift(>=4.2)

extension BLEReceiver_Zwift_PlayButtonStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///----------------- Zwift Ride messages
enum BLEReceiver_Zwift_RideButtonMask: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case leftBtn // = 1
  case upBtn // = 2
  case rightBtn // = 4
  case downBtn // = 8
  case aBtn // = 16
  case bBtn // = 32
  case yBtn // = 64
  case zBtn // = 256
  case shftUpLBtn // = 512
  case shftDnLBtn // = 1024
  case powerupLBtn // = 2048
  case onoffLBtn // = 4096
  case shftUpRBtn // = 8192
  case shftDnRBtn // = 16384
  case powerupRBtn // = 65536
  case onoffRBtn // = 131072

  init() {
    self = .leftBtn
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .leftBtn
    case 2: self = .upBtn
    case 4: self = .rightBtn
    case 8: self = .downBtn
    case 16: self = .aBtn
    case 32: self = .bBtn
    case 64: self = .yBtn
    case 256: self = .zBtn
    case 512: self = .shftUpLBtn
    case 1024: self = .shftDnLBtn
    case 2048: self = .powerupLBtn
    case 4096: self = .onoffLBtn
    case 8192: self = .shftUpRBtn
    case 16384: self = .shftDnRBtn
    case 65536: self = .powerupRBtn
    case 131072: self = .onoffRBtn
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .leftBtn: return 1
    case .upBtn: return 2
    case .rightBtn: return 4
    case .downBtn: return 8
    case .aBtn: return 16
    case .bBtn: return 32
    case .yBtn: return 64
    case .zBtn: return 256
    case .shftUpLBtn: return 512
    case .shftDnLBtn: return 1024
    case .powerupLBtn: return 2048
    case .onoffLBtn: return 4096
    case .shftUpRBtn: return 8192
    case .shftDnRBtn: return 16384
    case .powerupRBtn: return 65536
    case .onoffRBtn: return 131072
    }
  }

}

#if swift(>=4.2)

extension BLEReceiver_Zwift_RideButtonMask: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum BLEReceiver_Zwift_RideAnalogLocation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case left // = 0
  case right // = 1
  case up // = 2
  case down // = 3

  init() {
    self = .left
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .left
    case 1: self = .right
    case 2: self = .up
    case 3: self = .down
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .left: return 0
    case .right: return 1
    case .up: return 2
    case .down: return 3
    }
  }

}

#if swift(>=4.2)

extension BLEReceiver_Zwift_RideAnalogLocation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///-------------- Zwift Hub messages
/// The command code prepending this message is 0x00
/// This message is sent always following the change of the gear ratio probably to verify it was received properly
struct BLEReceiver_Zwift_HubRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value observed 520 and 0, 0 requests general info, 1-7 are the fields# in DeviceInformationContent, 520 requests the gear ratio
  var dataID: UInt32 {
    get {return _dataID ?? 0}
    set {_dataID = newValue}
  }
  /// Returns true if `dataID` has been explicitly set.
  var hasDataID: Bool {return self._dataID != nil}
  /// Clears the value of `dataID`. Subsequent reads from it will return its default value.
  mutating func clearDataID() {self._dataID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dataID: UInt32? = nil
}

/// The command code prepending this message is 0x03
struct BLEReceiver_Zwift_HubRidingData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var power: UInt32 {
    get {return _power ?? 0}
    set {_power = newValue}
  }
  /// Returns true if `power` has been explicitly set.
  var hasPower: Bool {return self._power != nil}
  /// Clears the value of `power`. Subsequent reads from it will return its default value.
  mutating func clearPower() {self._power = nil}

  var cadence: UInt32 {
    get {return _cadence ?? 0}
    set {_cadence = newValue}
  }
  /// Returns true if `cadence` has been explicitly set.
  var hasCadence: Bool {return self._cadence != nil}
  /// Clears the value of `cadence`. Subsequent reads from it will return its default value.
  mutating func clearCadence() {self._cadence = nil}

  var speedX100: UInt32 {
    get {return _speedX100 ?? 0}
    set {_speedX100 = newValue}
  }
  /// Returns true if `speedX100` has been explicitly set.
  var hasSpeedX100: Bool {return self._speedX100 != nil}
  /// Clears the value of `speedX100`. Subsequent reads from it will return its default value.
  mutating func clearSpeedX100() {self._speedX100 = nil}

  var hr: UInt32 {
    get {return _hr ?? 0}
    set {_hr = newValue}
  }
  /// Returns true if `hr` has been explicitly set.
  var hasHr: Bool {return self._hr != nil}
  /// Clears the value of `hr`. Subsequent reads from it will return its default value.
  mutating func clearHr() {self._hr = nil}

  /// Values observed 0 when stopped, 2864, 4060, 4636, 6803
  var unknown1: UInt32 {
    get {return _unknown1 ?? 0}
    set {_unknown1 = newValue}
  }
  /// Returns true if `unknown1` has been explicitly set.
  var hasUnknown1: Bool {return self._unknown1 != nil}
  /// Clears the value of `unknown1`. Subsequent reads from it will return its default value.
  mutating func clearUnknown1() {self._unknown1 = nil}

  /// Values observed 25714, 30091 (constant during session)
  var unknown2: UInt32 {
    get {return _unknown2 ?? 0}
    set {_unknown2 = newValue}
  }
  /// Returns true if `unknown2` has been explicitly set.
  var hasUnknown2: Bool {return self._unknown2 != nil}
  /// Clears the value of `unknown2`. Subsequent reads from it will return its default value.
  mutating func clearUnknown2() {self._unknown2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _power: UInt32? = nil
  fileprivate var _cadence: UInt32? = nil
  fileprivate var _speedX100: UInt32? = nil
  fileprivate var _hr: UInt32? = nil
  fileprivate var _unknown1: UInt32? = nil
  fileprivate var _unknown2: UInt32? = nil
}

struct BLEReceiver_Zwift_SimulationParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Wind in m/s * 100. In zwift there is no wind (0). Negative is backwind
  var wind: Int32 {
    get {return _wind ?? 0}
    set {_wind = newValue}
  }
  /// Returns true if `wind` has been explicitly set.
  var hasWind: Bool {return self._wind != nil}
  /// Clears the value of `wind`. Subsequent reads from it will return its default value.
  mutating func clearWind() {self._wind = nil}

  /// Incline value * 100  
  var inclineX100: Int32 {
    get {return _inclineX100 ?? 0}
    set {_inclineX100 = newValue}
  }
  /// Returns true if `inclineX100` has been explicitly set.
  var hasInclineX100: Bool {return self._inclineX100 != nil}
  /// Clears the value of `inclineX100`. Subsequent reads from it will return its default value.
  mutating func clearInclineX100() {self._inclineX100 = nil}

  /// Wind coefficient CW * a * 10000. In zwift this is constant 0.51 (5100) 
  var cwa: UInt32 {
    get {return _cwa ?? 0}
    set {_cwa = newValue}
  }
  /// Returns true if `cwa` has been explicitly set.
  var hasCwa: Bool {return self._cwa != nil}
  /// Clears the value of `cwa`. Subsequent reads from it will return its default value.
  mutating func clearCwa() {self._cwa = nil}

  /// Rolling resistance Crr * 100000. In zwift this is constant 0.004 (400)
  var crr: UInt32 {
    get {return _crr ?? 0}
    set {_crr = newValue}
  }
  /// Returns true if `crr` has been explicitly set.
  var hasCrr: Bool {return self._crr != nil}
  /// Clears the value of `crr`. Subsequent reads from it will return its default value.
  mutating func clearCrr() {self._crr = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _wind: Int32? = nil
  fileprivate var _inclineX100: Int32? = nil
  fileprivate var _cwa: UInt32? = nil
  fileprivate var _crr: UInt32? = nil
}

struct BLEReceiver_Zwift_PhysicalParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gearRatioX10000: UInt32 {
    get {return _gearRatioX10000 ?? 0}
    set {_gearRatioX10000 = newValue}
  }
  /// Returns true if `gearRatioX10000` has been explicitly set.
  var hasGearRatioX10000: Bool {return self._gearRatioX10000 != nil}
  /// Clears the value of `gearRatioX10000`. Subsequent reads from it will return its default value.
  mutating func clearGearRatioX10000() {self._gearRatioX10000 = nil}

  var bikeWeightx100: UInt32 {
    get {return _bikeWeightx100 ?? 0}
    set {_bikeWeightx100 = newValue}
  }
  /// Returns true if `bikeWeightx100` has been explicitly set.
  var hasBikeWeightx100: Bool {return self._bikeWeightx100 != nil}
  /// Clears the value of `bikeWeightx100`. Subsequent reads from it will return its default value.
  mutating func clearBikeWeightx100() {self._bikeWeightx100 = nil}

  var riderWeightx100: UInt32 {
    get {return _riderWeightx100 ?? 0}
    set {_riderWeightx100 = newValue}
  }
  /// Returns true if `riderWeightx100` has been explicitly set.
  var hasRiderWeightx100: Bool {return self._riderWeightx100 != nil}
  /// Clears the value of `riderWeightx100`. Subsequent reads from it will return its default value.
  mutating func clearRiderWeightx100() {self._riderWeightx100 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _gearRatioX10000: UInt32? = nil
  fileprivate var _bikeWeightx100: UInt32? = nil
  fileprivate var _riderWeightx100: UInt32? = nil
}

/// The command code prepending this message is 0x04
struct BLEReceiver_Zwift_HubCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var powerTarget: UInt32 {
    get {return _powerTarget ?? 0}
    set {_powerTarget = newValue}
  }
  /// Returns true if `powerTarget` has been explicitly set.
  var hasPowerTarget: Bool {return self._powerTarget != nil}
  /// Clears the value of `powerTarget`. Subsequent reads from it will return its default value.
  mutating func clearPowerTarget() {self._powerTarget = nil}

  var simulation: BLEReceiver_Zwift_SimulationParam {
    get {return _simulation ?? BLEReceiver_Zwift_SimulationParam()}
    set {_simulation = newValue}
  }
  /// Returns true if `simulation` has been explicitly set.
  var hasSimulation: Bool {return self._simulation != nil}
  /// Clears the value of `simulation`. Subsequent reads from it will return its default value.
  mutating func clearSimulation() {self._simulation = nil}

  var physical: BLEReceiver_Zwift_PhysicalParam {
    get {return _physical ?? BLEReceiver_Zwift_PhysicalParam()}
    set {_physical = newValue}
  }
  /// Returns true if `physical` has been explicitly set.
  var hasPhysical: Bool {return self._physical != nil}
  /// Clears the value of `physical`. Subsequent reads from it will return its default value.
  mutating func clearPhysical() {self._physical = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _powerTarget: UInt32? = nil
  fileprivate var _simulation: BLEReceiver_Zwift_SimulationParam? = nil
  fileprivate var _physical: BLEReceiver_Zwift_PhysicalParam? = nil
}

/// The command code prepending this message is 0x07
struct BLEReceiver_Zwift_PlayKeyPadStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rightPad: BLEReceiver_Zwift_PlayButtonStatus {
    get {return _rightPad ?? .on}
    set {_rightPad = newValue}
  }
  /// Returns true if `rightPad` has been explicitly set.
  var hasRightPad: Bool {return self._rightPad != nil}
  /// Clears the value of `rightPad`. Subsequent reads from it will return its default value.
  mutating func clearRightPad() {self._rightPad = nil}

  var buttonYUp: BLEReceiver_Zwift_PlayButtonStatus {
    get {return _buttonYUp ?? .on}
    set {_buttonYUp = newValue}
  }
  /// Returns true if `buttonYUp` has been explicitly set.
  var hasButtonYUp: Bool {return self._buttonYUp != nil}
  /// Clears the value of `buttonYUp`. Subsequent reads from it will return its default value.
  mutating func clearButtonYUp() {self._buttonYUp = nil}

  var buttonZLeft: BLEReceiver_Zwift_PlayButtonStatus {
    get {return _buttonZLeft ?? .on}
    set {_buttonZLeft = newValue}
  }
  /// Returns true if `buttonZLeft` has been explicitly set.
  var hasButtonZLeft: Bool {return self._buttonZLeft != nil}
  /// Clears the value of `buttonZLeft`. Subsequent reads from it will return its default value.
  mutating func clearButtonZLeft() {self._buttonZLeft = nil}

  var buttonARight: BLEReceiver_Zwift_PlayButtonStatus {
    get {return _buttonARight ?? .on}
    set {_buttonARight = newValue}
  }
  /// Returns true if `buttonARight` has been explicitly set.
  var hasButtonARight: Bool {return self._buttonARight != nil}
  /// Clears the value of `buttonARight`. Subsequent reads from it will return its default value.
  mutating func clearButtonARight() {self._buttonARight = nil}

  var buttonBDown: BLEReceiver_Zwift_PlayButtonStatus {
    get {return _buttonBDown ?? .on}
    set {_buttonBDown = newValue}
  }
  /// Returns true if `buttonBDown` has been explicitly set.
  var hasButtonBDown: Bool {return self._buttonBDown != nil}
  /// Clears the value of `buttonBDown`. Subsequent reads from it will return its default value.
  mutating func clearButtonBDown() {self._buttonBDown = nil}

  var buttonOn: BLEReceiver_Zwift_PlayButtonStatus {
    get {return _buttonOn ?? .on}
    set {_buttonOn = newValue}
  }
  /// Returns true if `buttonOn` has been explicitly set.
  var hasButtonOn: Bool {return self._buttonOn != nil}
  /// Clears the value of `buttonOn`. Subsequent reads from it will return its default value.
  mutating func clearButtonOn() {self._buttonOn = nil}

  var buttonShift: BLEReceiver_Zwift_PlayButtonStatus {
    get {return _buttonShift ?? .on}
    set {_buttonShift = newValue}
  }
  /// Returns true if `buttonShift` has been explicitly set.
  var hasButtonShift: Bool {return self._buttonShift != nil}
  /// Clears the value of `buttonShift`. Subsequent reads from it will return its default value.
  mutating func clearButtonShift() {self._buttonShift = nil}

  var analogLr: Int32 {
    get {return _analogLr ?? 0}
    set {_analogLr = newValue}
  }
  /// Returns true if `analogLr` has been explicitly set.
  var hasAnalogLr: Bool {return self._analogLr != nil}
  /// Clears the value of `analogLr`. Subsequent reads from it will return its default value.
  mutating func clearAnalogLr() {self._analogLr = nil}

  var analogUd: Int32 {
    get {return _analogUd ?? 0}
    set {_analogUd = newValue}
  }
  /// Returns true if `analogUd` has been explicitly set.
  var hasAnalogUd: Bool {return self._analogUd != nil}
  /// Clears the value of `analogUd`. Subsequent reads from it will return its default value.
  mutating func clearAnalogUd() {self._analogUd = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rightPad: BLEReceiver_Zwift_PlayButtonStatus? = nil
  fileprivate var _buttonYUp: BLEReceiver_Zwift_PlayButtonStatus? = nil
  fileprivate var _buttonZLeft: BLEReceiver_Zwift_PlayButtonStatus? = nil
  fileprivate var _buttonARight: BLEReceiver_Zwift_PlayButtonStatus? = nil
  fileprivate var _buttonBDown: BLEReceiver_Zwift_PlayButtonStatus? = nil
  fileprivate var _buttonOn: BLEReceiver_Zwift_PlayButtonStatus? = nil
  fileprivate var _buttonShift: BLEReceiver_Zwift_PlayButtonStatus? = nil
  fileprivate var _analogLr: Int32? = nil
  fileprivate var _analogUd: Int32? = nil
}

struct BLEReceiver_Zwift_PlayCommandParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var param1: UInt32 {
    get {return _param1 ?? 0}
    set {_param1 = newValue}
  }
  /// Returns true if `param1` has been explicitly set.
  var hasParam1: Bool {return self._param1 != nil}
  /// Clears the value of `param1`. Subsequent reads from it will return its default value.
  mutating func clearParam1() {self._param1 = nil}

  var param2: UInt32 {
    get {return _param2 ?? 0}
    set {_param2 = newValue}
  }
  /// Returns true if `param2` has been explicitly set.
  var hasParam2: Bool {return self._param2 != nil}
  /// Clears the value of `param2`. Subsequent reads from it will return its default value.
  mutating func clearParam2() {self._param2 = nil}

  var hapticPattern: UInt32 {
    get {return _hapticPattern ?? 0}
    set {_hapticPattern = newValue}
  }
  /// Returns true if `hapticPattern` has been explicitly set.
  var hasHapticPattern: Bool {return self._hapticPattern != nil}
  /// Clears the value of `hapticPattern`. Subsequent reads from it will return its default value.
  mutating func clearHapticPattern() {self._hapticPattern = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _param1: UInt32? = nil
  fileprivate var _param2: UInt32? = nil
  fileprivate var _hapticPattern: UInt32? = nil
}

struct BLEReceiver_Zwift_PlayCommandContents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var commandParameters: BLEReceiver_Zwift_PlayCommandParameters {
    get {return _commandParameters ?? BLEReceiver_Zwift_PlayCommandParameters()}
    set {_commandParameters = newValue}
  }
  /// Returns true if `commandParameters` has been explicitly set.
  var hasCommandParameters: Bool {return self._commandParameters != nil}
  /// Clears the value of `commandParameters`. Subsequent reads from it will return its default value.
  mutating func clearCommandParameters() {self._commandParameters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandParameters: BLEReceiver_Zwift_PlayCommandParameters? = nil
}

/// The command code prepending this message is 0x12
/// This is sent to the control point to configure and make the controller vibrate 
struct BLEReceiver_Zwift_PlayCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var commandContents: BLEReceiver_Zwift_PlayCommandContents {
    get {return _commandContents ?? BLEReceiver_Zwift_PlayCommandContents()}
    set {_commandContents = newValue}
  }
  /// Returns true if `commandContents` has been explicitly set.
  var hasCommandContents: Bool {return self._commandContents != nil}
  /// Clears the value of `commandContents`. Subsequent reads from it will return its default value.
  mutating func clearCommandContents() {self._commandContents = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandContents: BLEReceiver_Zwift_PlayCommandContents? = nil
}

/// The command code prepending this message is 0x19
/// This is sent periodically when there are no button presses
struct BLEReceiver_Zwift_Idle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknown2: UInt32 {
    get {return _unknown2 ?? 0}
    set {_unknown2 = newValue}
  }
  /// Returns true if `unknown2` has been explicitly set.
  var hasUnknown2: Bool {return self._unknown2 != nil}
  /// Clears the value of `unknown2`. Subsequent reads from it will return its default value.
  mutating func clearUnknown2() {self._unknown2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unknown2: UInt32? = nil
}

struct BLEReceiver_Zwift_RideAnalogKeyPress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: BLEReceiver_Zwift_RideAnalogLocation {
    get {return _location ?? .left}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  var analogValue: Int32 {
    get {return _analogValue ?? 0}
    set {_analogValue = newValue}
  }
  /// Returns true if `analogValue` has been explicitly set.
  var hasAnalogValue: Bool {return self._analogValue != nil}
  /// Clears the value of `analogValue`. Subsequent reads from it will return its default value.
  mutating func clearAnalogValue() {self._analogValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _location: BLEReceiver_Zwift_RideAnalogLocation? = nil
  fileprivate var _analogValue: Int32? = nil
}

struct BLEReceiver_Zwift_RideAnalogKeyGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupStatus: [BLEReceiver_Zwift_RideAnalogKeyPress] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The command code prepending this message is 0x23
struct BLEReceiver_Zwift_RideKeyPadStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var buttonMap: UInt32 {
    get {return _buttonMap ?? 0}
    set {_buttonMap = newValue}
  }
  /// Returns true if `buttonMap` has been explicitly set.
  var hasButtonMap: Bool {return self._buttonMap != nil}
  /// Clears the value of `buttonMap`. Subsequent reads from it will return its default value.
  mutating func clearButtonMap() {self._buttonMap = nil}

  var analogButtons: BLEReceiver_Zwift_RideAnalogKeyGroup {
    get {return _analogButtons ?? BLEReceiver_Zwift_RideAnalogKeyGroup()}
    set {_analogButtons = newValue}
  }
  /// Returns true if `analogButtons` has been explicitly set.
  var hasAnalogButtons: Bool {return self._analogButtons != nil}
  /// Clears the value of `analogButtons`. Subsequent reads from it will return its default value.
  mutating func clearAnalogButtons() {self._analogButtons = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _buttonMap: UInt32? = nil
  fileprivate var _analogButtons: BLEReceiver_Zwift_RideAnalogKeyGroup? = nil
}

///------------------ Zwift Click messages
/// The command code prepending this message is 0x37
struct BLEReceiver_Zwift_ClickKeyPadStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var buttonPlus: BLEReceiver_Zwift_PlayButtonStatus {
    get {return _buttonPlus ?? .on}
    set {_buttonPlus = newValue}
  }
  /// Returns true if `buttonPlus` has been explicitly set.
  var hasButtonPlus: Bool {return self._buttonPlus != nil}
  /// Clears the value of `buttonPlus`. Subsequent reads from it will return its default value.
  mutating func clearButtonPlus() {self._buttonPlus = nil}

  var buttonMinus: BLEReceiver_Zwift_PlayButtonStatus {
    get {return _buttonMinus ?? .on}
    set {_buttonMinus = newValue}
  }
  /// Returns true if `buttonMinus` has been explicitly set.
  var hasButtonMinus: Bool {return self._buttonMinus != nil}
  /// Clears the value of `buttonMinus`. Subsequent reads from it will return its default value.
  mutating func clearButtonMinus() {self._buttonMinus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _buttonPlus: BLEReceiver_Zwift_PlayButtonStatus? = nil
  fileprivate var _buttonMinus: BLEReceiver_Zwift_PlayButtonStatus? = nil
}

///------------------ Device Information requested after connection
/// The command code prepending this message is 0x3c
struct BLEReceiver_Zwift_DeviceInformationContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknown1: UInt32 {
    get {return _unknown1 ?? 0}
    set {_unknown1 = newValue}
  }
  /// Returns true if `unknown1` has been explicitly set.
  var hasUnknown1: Bool {return self._unknown1 != nil}
  /// Clears the value of `unknown1`. Subsequent reads from it will return its default value.
  mutating func clearUnknown1() {self._unknown1 = nil}

  var softwareVersion: [UInt32] = []

  var deviceName: String {
    get {return _deviceName ?? String()}
    set {_deviceName = newValue}
  }
  /// Returns true if `deviceName` has been explicitly set.
  var hasDeviceName: Bool {return self._deviceName != nil}
  /// Clears the value of `deviceName`. Subsequent reads from it will return its default value.
  mutating func clearDeviceName() {self._deviceName = nil}

  var unknown4: UInt32 {
    get {return _unknown4 ?? 0}
    set {_unknown4 = newValue}
  }
  /// Returns true if `unknown4` has been explicitly set.
  var hasUnknown4: Bool {return self._unknown4 != nil}
  /// Clears the value of `unknown4`. Subsequent reads from it will return its default value.
  mutating func clearUnknown4() {self._unknown4 = nil}

  var unknown5: UInt32 {
    get {return _unknown5 ?? 0}
    set {_unknown5 = newValue}
  }
  /// Returns true if `unknown5` has been explicitly set.
  var hasUnknown5: Bool {return self._unknown5 != nil}
  /// Clears the value of `unknown5`. Subsequent reads from it will return its default value.
  mutating func clearUnknown5() {self._unknown5 = nil}

  var serialNumber: String {
    get {return _serialNumber ?? String()}
    set {_serialNumber = newValue}
  }
  /// Returns true if `serialNumber` has been explicitly set.
  var hasSerialNumber: Bool {return self._serialNumber != nil}
  /// Clears the value of `serialNumber`. Subsequent reads from it will return its default value.
  mutating func clearSerialNumber() {self._serialNumber = nil}

  var hardwareVersion: String {
    get {return _hardwareVersion ?? String()}
    set {_hardwareVersion = newValue}
  }
  /// Returns true if `hardwareVersion` has been explicitly set.
  var hasHardwareVersion: Bool {return self._hardwareVersion != nil}
  /// Clears the value of `hardwareVersion`. Subsequent reads from it will return its default value.
  mutating func clearHardwareVersion() {self._hardwareVersion = nil}

  var replyData: [UInt32] = []

  var unknown9: UInt32 {
    get {return _unknown9 ?? 0}
    set {_unknown9 = newValue}
  }
  /// Returns true if `unknown9` has been explicitly set.
  var hasUnknown9: Bool {return self._unknown9 != nil}
  /// Clears the value of `unknown9`. Subsequent reads from it will return its default value.
  mutating func clearUnknown9() {self._unknown9 = nil}

  var unknown10: UInt32 {
    get {return _unknown10 ?? 0}
    set {_unknown10 = newValue}
  }
  /// Returns true if `unknown10` has been explicitly set.
  var hasUnknown10: Bool {return self._unknown10 != nil}
  /// Clears the value of `unknown10`. Subsequent reads from it will return its default value.
  mutating func clearUnknown10() {self._unknown10 = nil}

  var unknown13: UInt32 {
    get {return _unknown13 ?? 0}
    set {_unknown13 = newValue}
  }
  /// Returns true if `unknown13` has been explicitly set.
  var hasUnknown13: Bool {return self._unknown13 != nil}
  /// Clears the value of `unknown13`. Subsequent reads from it will return its default value.
  mutating func clearUnknown13() {self._unknown13 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unknown1: UInt32? = nil
  fileprivate var _deviceName: String? = nil
  fileprivate var _unknown4: UInt32? = nil
  fileprivate var _unknown5: UInt32? = nil
  fileprivate var _serialNumber: String? = nil
  fileprivate var _hardwareVersion: String? = nil
  fileprivate var _unknown9: UInt32? = nil
  fileprivate var _unknown10: UInt32? = nil
  fileprivate var _unknown13: UInt32? = nil
}

struct BLEReceiver_Zwift_SubContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: BLEReceiver_Zwift_DeviceInformationContent {
    get {return _content ?? BLEReceiver_Zwift_DeviceInformationContent()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  var unknown2: UInt32 {
    get {return _unknown2 ?? 0}
    set {_unknown2 = newValue}
  }
  /// Returns true if `unknown2` has been explicitly set.
  var hasUnknown2: Bool {return self._unknown2 != nil}
  /// Clears the value of `unknown2`. Subsequent reads from it will return its default value.
  mutating func clearUnknown2() {self._unknown2 = nil}

  var unknown4: UInt32 {
    get {return _unknown4 ?? 0}
    set {_unknown4 = newValue}
  }
  /// Returns true if `unknown4` has been explicitly set.
  var hasUnknown4: Bool {return self._unknown4 != nil}
  /// Clears the value of `unknown4`. Subsequent reads from it will return its default value.
  mutating func clearUnknown4() {self._unknown4 = nil}

  var unknown5: UInt32 {
    get {return _unknown5 ?? 0}
    set {_unknown5 = newValue}
  }
  /// Returns true if `unknown5` has been explicitly set.
  var hasUnknown5: Bool {return self._unknown5 != nil}
  /// Clears the value of `unknown5`. Subsequent reads from it will return its default value.
  mutating func clearUnknown5() {self._unknown5 = nil}

  var unknown6: UInt32 {
    get {return _unknown6 ?? 0}
    set {_unknown6 = newValue}
  }
  /// Returns true if `unknown6` has been explicitly set.
  var hasUnknown6: Bool {return self._unknown6 != nil}
  /// Clears the value of `unknown6`. Subsequent reads from it will return its default value.
  mutating func clearUnknown6() {self._unknown6 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _content: BLEReceiver_Zwift_DeviceInformationContent? = nil
  fileprivate var _unknown2: UInt32? = nil
  fileprivate var _unknown4: UInt32? = nil
  fileprivate var _unknown5: UInt32? = nil
  fileprivate var _unknown6: UInt32? = nil
}

struct BLEReceiver_Zwift_DeviceInformation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var informationID: UInt32 {
    get {return _informationID ?? 0}
    set {_informationID = newValue}
  }
  /// Returns true if `informationID` has been explicitly set.
  var hasInformationID: Bool {return self._informationID != nil}
  /// Clears the value of `informationID`. Subsequent reads from it will return its default value.
  mutating func clearInformationID() {self._informationID = nil}

  var subContent: BLEReceiver_Zwift_SubContent {
    get {return _subContent ?? BLEReceiver_Zwift_SubContent()}
    set {_subContent = newValue}
  }
  /// Returns true if `subContent` has been explicitly set.
  var hasSubContent: Bool {return self._subContent != nil}
  /// Clears the value of `subContent`. Subsequent reads from it will return its default value.
  mutating func clearSubContent() {self._subContent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _informationID: UInt32? = nil
  fileprivate var _subContent: BLEReceiver_Zwift_SubContent? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension BLEReceiver_Zwift_PlayButtonStatus: @unchecked Sendable {}
extension BLEReceiver_Zwift_RideButtonMask: @unchecked Sendable {}
extension BLEReceiver_Zwift_RideAnalogLocation: @unchecked Sendable {}
extension BLEReceiver_Zwift_HubRequest: @unchecked Sendable {}
extension BLEReceiver_Zwift_HubRidingData: @unchecked Sendable {}
extension BLEReceiver_Zwift_SimulationParam: @unchecked Sendable {}
extension BLEReceiver_Zwift_PhysicalParam: @unchecked Sendable {}
extension BLEReceiver_Zwift_HubCommand: @unchecked Sendable {}
extension BLEReceiver_Zwift_PlayKeyPadStatus: @unchecked Sendable {}
extension BLEReceiver_Zwift_PlayCommandParameters: @unchecked Sendable {}
extension BLEReceiver_Zwift_PlayCommandContents: @unchecked Sendable {}
extension BLEReceiver_Zwift_PlayCommand: @unchecked Sendable {}
extension BLEReceiver_Zwift_Idle: @unchecked Sendable {}
extension BLEReceiver_Zwift_RideAnalogKeyPress: @unchecked Sendable {}
extension BLEReceiver_Zwift_RideAnalogKeyGroup: @unchecked Sendable {}
extension BLEReceiver_Zwift_RideKeyPadStatus: @unchecked Sendable {}
extension BLEReceiver_Zwift_ClickKeyPadStatus: @unchecked Sendable {}
extension BLEReceiver_Zwift_DeviceInformationContent: @unchecked Sendable {}
extension BLEReceiver_Zwift_SubContent: @unchecked Sendable {}
extension BLEReceiver_Zwift_DeviceInformation: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "BLEReceiver.Zwift"

extension BLEReceiver_Zwift_PlayButtonStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ON"),
    1: .same(proto: "OFF"),
  ]
}

extension BLEReceiver_Zwift_RideButtonMask: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "LEFT_BTN"),
    2: .same(proto: "UP_BTN"),
    4: .same(proto: "RIGHT_BTN"),
    8: .same(proto: "DOWN_BTN"),
    16: .same(proto: "A_BTN"),
    32: .same(proto: "B_BTN"),
    64: .same(proto: "Y_BTN"),
    256: .same(proto: "Z_BTN"),
    512: .same(proto: "SHFT_UP_L_BTN"),
    1024: .same(proto: "SHFT_DN_L_BTN"),
    2048: .same(proto: "POWERUP_L_BTN"),
    4096: .same(proto: "ONOFF_L_BTN"),
    8192: .same(proto: "SHFT_UP_R_BTN"),
    16384: .same(proto: "SHFT_DN_R_BTN"),
    65536: .same(proto: "POWERUP_R_BTN"),
    131072: .same(proto: "ONOFF_R_BTN"),
  ]
}

extension BLEReceiver_Zwift_RideAnalogLocation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LEFT"),
    1: .same(proto: "RIGHT"),
    2: .same(proto: "UP"),
    3: .same(proto: "DOWN"),
  ]
}

extension BLEReceiver_Zwift_HubRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HubRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DataId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._dataID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dataID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_HubRequest, rhs: BLEReceiver_Zwift_HubRequest) -> Bool {
    if lhs._dataID != rhs._dataID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_HubRidingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HubRidingData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Power"),
    2: .same(proto: "Cadence"),
    3: .same(proto: "SpeedX100"),
    4: .same(proto: "HR"),
    5: .same(proto: "Unknown1"),
    6: .same(proto: "Unknown2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._power) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._cadence) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._speedX100) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._hr) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._unknown1) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._unknown2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._power {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cadence {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._speedX100 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._hr {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._unknown1 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._unknown2 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_HubRidingData, rhs: BLEReceiver_Zwift_HubRidingData) -> Bool {
    if lhs._power != rhs._power {return false}
    if lhs._cadence != rhs._cadence {return false}
    if lhs._speedX100 != rhs._speedX100 {return false}
    if lhs._hr != rhs._hr {return false}
    if lhs._unknown1 != rhs._unknown1 {return false}
    if lhs._unknown2 != rhs._unknown2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_SimulationParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimulationParam"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Wind"),
    2: .same(proto: "InclineX100"),
    3: .same(proto: "CWa"),
    4: .same(proto: "Crr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSInt32Field(value: &self._wind) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self._inclineX100) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._cwa) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._crr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._wind {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inclineX100 {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cwa {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._crr {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_SimulationParam, rhs: BLEReceiver_Zwift_SimulationParam) -> Bool {
    if lhs._wind != rhs._wind {return false}
    if lhs._inclineX100 != rhs._inclineX100 {return false}
    if lhs._cwa != rhs._cwa {return false}
    if lhs._crr != rhs._crr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_PhysicalParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PhysicalParam"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "GearRatioX10000"),
    4: .same(proto: "BikeWeightx100"),
    5: .same(proto: "RiderWeightx100"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._gearRatioX10000) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._bikeWeightx100) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._riderWeightx100) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gearRatioX10000 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bikeWeightx100 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._riderWeightx100 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_PhysicalParam, rhs: BLEReceiver_Zwift_PhysicalParam) -> Bool {
    if lhs._gearRatioX10000 != rhs._gearRatioX10000 {return false}
    if lhs._bikeWeightx100 != rhs._bikeWeightx100 {return false}
    if lhs._riderWeightx100 != rhs._riderWeightx100 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_HubCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HubCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "PowerTarget"),
    4: .same(proto: "Simulation"),
    5: .same(proto: "Physical"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._powerTarget) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._simulation) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._physical) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._powerTarget {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._simulation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._physical {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_HubCommand, rhs: BLEReceiver_Zwift_HubCommand) -> Bool {
    if lhs._powerTarget != rhs._powerTarget {return false}
    if lhs._simulation != rhs._simulation {return false}
    if lhs._physical != rhs._physical {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_PlayKeyPadStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayKeyPadStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RightPad"),
    2: .standard(proto: "Button_Y_Up"),
    3: .standard(proto: "Button_Z_Left"),
    4: .standard(proto: "Button_A_Right"),
    5: .standard(proto: "Button_B_Down"),
    6: .standard(proto: "Button_On"),
    7: .standard(proto: "Button_Shift"),
    8: .standard(proto: "Analog_LR"),
    9: .standard(proto: "Analog_UD"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._rightPad) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._buttonYUp) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._buttonZLeft) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._buttonARight) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._buttonBDown) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._buttonOn) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._buttonShift) }()
      case 8: try { try decoder.decodeSingularSInt32Field(value: &self._analogLr) }()
      case 9: try { try decoder.decodeSingularSInt32Field(value: &self._analogUd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rightPad {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._buttonYUp {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._buttonZLeft {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._buttonARight {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._buttonBDown {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._buttonOn {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._buttonShift {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._analogLr {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._analogUd {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_PlayKeyPadStatus, rhs: BLEReceiver_Zwift_PlayKeyPadStatus) -> Bool {
    if lhs._rightPad != rhs._rightPad {return false}
    if lhs._buttonYUp != rhs._buttonYUp {return false}
    if lhs._buttonZLeft != rhs._buttonZLeft {return false}
    if lhs._buttonARight != rhs._buttonARight {return false}
    if lhs._buttonBDown != rhs._buttonBDown {return false}
    if lhs._buttonOn != rhs._buttonOn {return false}
    if lhs._buttonShift != rhs._buttonShift {return false}
    if lhs._analogLr != rhs._analogLr {return false}
    if lhs._analogUd != rhs._analogUd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_PlayCommandParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayCommandParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "param1"),
    2: .same(proto: "param2"),
    3: .same(proto: "HapticPattern"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._param1) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._param2) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._hapticPattern) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._param1 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._param2 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hapticPattern {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_PlayCommandParameters, rhs: BLEReceiver_Zwift_PlayCommandParameters) -> Bool {
    if lhs._param1 != rhs._param1 {return false}
    if lhs._param2 != rhs._param2 {return false}
    if lhs._hapticPattern != rhs._hapticPattern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_PlayCommandContents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayCommandContents"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CommandParameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandParameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_PlayCommandContents, rhs: BLEReceiver_Zwift_PlayCommandContents) -> Bool {
    if lhs._commandParameters != rhs._commandParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_PlayCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "CommandContents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._commandContents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandContents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_PlayCommand, rhs: BLEReceiver_Zwift_PlayCommand) -> Bool {
    if lhs._commandContents != rhs._commandContents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_Idle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Idle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "Unknown2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._unknown2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unknown2 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_Idle, rhs: BLEReceiver_Zwift_Idle) -> Bool {
    if lhs._unknown2 != rhs._unknown2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_RideAnalogKeyPress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RideAnalogKeyPress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Location"),
    2: .same(proto: "AnalogValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._location) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self._analogValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._location {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._analogValue {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_RideAnalogKeyPress, rhs: BLEReceiver_Zwift_RideAnalogKeyPress) -> Bool {
    if lhs._location != rhs._location {return false}
    if lhs._analogValue != rhs._analogValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_RideAnalogKeyGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RideAnalogKeyGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GroupStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groupStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupStatus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupStatus, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_RideAnalogKeyGroup, rhs: BLEReceiver_Zwift_RideAnalogKeyGroup) -> Bool {
    if lhs.groupStatus != rhs.groupStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_RideKeyPadStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RideKeyPadStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ButtonMap"),
    2: .same(proto: "AnalogButtons"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._buttonMap) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._analogButtons) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._buttonMap {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._analogButtons {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_RideKeyPadStatus, rhs: BLEReceiver_Zwift_RideKeyPadStatus) -> Bool {
    if lhs._buttonMap != rhs._buttonMap {return false}
    if lhs._analogButtons != rhs._analogButtons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_ClickKeyPadStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClickKeyPadStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Button_Plus"),
    2: .standard(proto: "Button_Minus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._buttonPlus) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._buttonMinus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._buttonPlus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._buttonMinus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_ClickKeyPadStatus, rhs: BLEReceiver_Zwift_ClickKeyPadStatus) -> Bool {
    if lhs._buttonPlus != rhs._buttonPlus {return false}
    if lhs._buttonMinus != rhs._buttonMinus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_DeviceInformationContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceInformationContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Unknown1"),
    2: .same(proto: "SoftwareVersion"),
    3: .same(proto: "DeviceName"),
    4: .same(proto: "Unknown4"),
    5: .same(proto: "Unknown5"),
    6: .same(proto: "SerialNumber"),
    7: .same(proto: "HardwareVersion"),
    8: .same(proto: "ReplyData"),
    9: .same(proto: "Unknown9"),
    10: .same(proto: "Unknown10"),
    13: .same(proto: "Unknown13"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._unknown1) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.softwareVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._deviceName) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._unknown4) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._unknown5) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._serialNumber) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._hardwareVersion) }()
      case 8: try { try decoder.decodeRepeatedUInt32Field(value: &self.replyData) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._unknown9) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._unknown10) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self._unknown13) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unknown1 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.softwareVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.softwareVersion, fieldNumber: 2)
    }
    try { if let v = self._deviceName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._unknown4 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._unknown5 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._serialNumber {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._hardwareVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    if !self.replyData.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.replyData, fieldNumber: 8)
    }
    try { if let v = self._unknown9 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._unknown10 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._unknown13 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_DeviceInformationContent, rhs: BLEReceiver_Zwift_DeviceInformationContent) -> Bool {
    if lhs._unknown1 != rhs._unknown1 {return false}
    if lhs.softwareVersion != rhs.softwareVersion {return false}
    if lhs._deviceName != rhs._deviceName {return false}
    if lhs._unknown4 != rhs._unknown4 {return false}
    if lhs._unknown5 != rhs._unknown5 {return false}
    if lhs._serialNumber != rhs._serialNumber {return false}
    if lhs._hardwareVersion != rhs._hardwareVersion {return false}
    if lhs.replyData != rhs.replyData {return false}
    if lhs._unknown9 != rhs._unknown9 {return false}
    if lhs._unknown10 != rhs._unknown10 {return false}
    if lhs._unknown13 != rhs._unknown13 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_SubContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Content"),
    2: .same(proto: "Unknown2"),
    4: .same(proto: "Unknown4"),
    5: .same(proto: "Unknown5"),
    6: .same(proto: "Unknown6"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._unknown2) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._unknown4) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._unknown5) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._unknown6) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unknown2 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._unknown4 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._unknown5 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._unknown6 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_SubContent, rhs: BLEReceiver_Zwift_SubContent) -> Bool {
    if lhs._content != rhs._content {return false}
    if lhs._unknown2 != rhs._unknown2 {return false}
    if lhs._unknown4 != rhs._unknown4 {return false}
    if lhs._unknown5 != rhs._unknown5 {return false}
    if lhs._unknown6 != rhs._unknown6 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEReceiver_Zwift_DeviceInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "InformationId"),
    2: .same(proto: "SubContent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._informationID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._subContent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._informationID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._subContent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEReceiver_Zwift_DeviceInformation, rhs: BLEReceiver_Zwift_DeviceInformation) -> Bool {
    if lhs._informationID != rhs._informationID {return false}
    if lhs._subContent != rhs._subContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
